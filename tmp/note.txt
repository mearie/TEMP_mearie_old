====== mearieflo ======

//minimalistic approach to personal website construction.//

메아리 플로(또는 줄여서 플로)는 파이썬으로 만들어진 웹 서버 어댑터
프레임워크이다. 웹 프레임워크의 복잡도를 피하면서 개인 홈페이지와 같이
content-intensive한 웹사이트를 최소한의 코드와 노력만으로 관리할 수 있게 하는
것이 목적이다.

===== 기능 =====

  * WSGI-compliant adapter (mod_wsgi 같은 거랑 연동해서 쓸 수 있음)
  * mako 템플릿 엔진을 사용한 강력한 텍스트 전처리기
    * 레이아웃, 헤더, 푸터 등의 처리가 매우 간단해짐
    * PSP(python server page)처럼 안에 inline script를 쓸 수도 있음
    * 기본 템플릿 라이브러리: form builder, 문법 강조(pygments), ...
  * 자체적인 후처리 프로세스
    * HTML에 국한되지 않음: 이미지 파일 thumbnail 기능, 파이썬 스크립트 수행 등
    * 최종 출력된 HTML의 validity를 유지하기 위한 일부 기능 추가 (e.g. img 등의
      엘리먼트에 모자라는 속성 추가하기)
  * 파일 시스템과 1:1 매칭되는 웹사이트 구조
    * 백업이 아주 직관적임!
    * 기본적인 리소스에 적용 (e.g. 외부에서 입력되는 블로그 글에도 포함)
    * manual synchronization을 지원하므로 웹 서버 상에서 직접 고쳐도 됨
      (''flo-sync''?)
    * 서브버전 등의 VCS와 연동 가능
  * HTTP의 기능을 일반 웹 서버보다 더 잘 지원
    * 다국어 지원을 위한 content negotiation (e.g. index.ko.html, index.ja.html)
    * method에 따라 다른 파일을 부르게 할 수 있음 (e.g. add_post.GET.html,
      add_post.POST.py)
    * HTTP 메타 데이터 처리를 간단하게 (e.g. index.ko.moved의 파일 내용에 URL이
      등등...)
    * path delegation 따위...
  * SQLite를 사용한 부가 데이터베이스
    * 간단한 ORM을 내장할 가능성 있는데 귀찮아서 할진 모르겠음
  * 개인 웹사이트 제작에 알맞은 빌트인 루틴
    * 모든 리소스에 달 수 있는 comment/trackback/and so on
    * synchronization에서 sitemap도 함께 만들어 줌
    * directory based feed
  * 당연히; 자유 소프트웨어 (MIT license 내지는 public domain)

==== '안'-기능 ====
(흔히 non-goal 또는 non-feature라고 부르는 것들)

  * 일반적인 형태의 웹 프레임워크가 아님
    * 일반 웹 서버와 거의 똑같은 형태로 동작함 (자체적인 path resolution
      프로세스)
    * 페이지나 기능을 추가하기 위해서 별도의 파일을 건들 필요 없이 바로 해당하는
      파일시스템에 넣으면 끝
  * Content management system도 아님
    * 비슷한 형태로 쓸 수는 있지만 그 정도의 복잡도가 기본으로 내장된 건 아님
    * 기본적으로 대부분의 컨텐츠가 서버에 접근할 수 있는 한 두 사람에 의해
      만들어짐을 가정하였으므로 거기에 맞춰서 설계되어 있음
    * 어차피 기본 컨텐츠가 데이터베이스에 의존하지 않기 때문에 CMS 수준의
      management 자체가 힘듬 (e.g. 검색 기능은 기본적으로 제공되지 않는다)
  * 쥐뿔도 모르는 사람이 쓸 수는 없음
    * 파이썬과 웹(HTTP, HTML 등)에 대한 어느 정도의 지식이 요구됨
    * 웹 사이트를 사용하는 사람들에게 편의를 제공할 수는 있지만 만드는
      사람들에게 극단적인 편의를 제공하지는 않음

===== URL resolution process =====

플로는 다음과 같은 과정을 거쳐 URL에 해당하는 파일을 찾는다. (예시용 URL은
''/foo/bar/quux'')
  * HTTP 헤더나 쿠키 등에서 사용자 정보를 끄집어 낸다. (e.g. 기본 언어)
  * 다국어 지원이 활성화되어 있고, 주어진 URL이 그 다국어 지원 URL에 해당할 경우
    canonical URL만 떼어낸 뒤 기본 언어를 변경한다.
  * URL의 각 component를 하나씩 자르면서 해당 "디렉토리"가 있는지 확인한다. (이
    경우 ''$BASE/foo/bar/quux/'', ''$BASE/foo/bar/'', ''$BASE/foo/'',
    ''$BASE/'')
    * 만약 주어진 URL이 그대로 디렉토리이고(예제에서는 맨 첫번째 케이스) URL의
      맨 마지막 글자가 /가 아니면 그 쪽으로 permanent redirect한다.
    * ''$BASE'' 디렉토리 자체가 없어서 체크가 실패하면 internal server error.
  * 디렉토리 다음 component에 해당하는 파일 이름이 prefix가 된다. 만약 prefix
    뒤에 더 남아 있는 게 있으면 (e.g. ''$BASE/foo/''가 디렉토리고
    ''$BASE/foo/bar''에 대응하는 파일이 있는 경우) 나머지 남는 것은 나중에
    slug로 전달된다.
  * prefix로 시작하는 파일 이름들을 모두 glob한 뒤 아파치 negotiation 과정에
    맞춰서 q 값들의 곱을 계산한다. (Accept에 없는 기본 언어의 경우 q=1.0으로
    가정한다. 그거 말고는 별 다른 거 없음) 이 과정은 당연히 캐싱되는 게 좋을
    것이다.
    * 만약 ''.GET.'', ''.POST.'' 같은 component가 있을 경우 현재 method에
      매칭되지 않으면 q=0.0, 매칭되면 q=1.0으로 처리한다. 기본값은 q=0.1?
    * HTTP 메타 데이터는 추후 처리
  * 가장 q값의 곱이 높은 파일을 serve한다.
    * 만약 이러한 파일이 없을 경우, not found를 뱉고 끝낸다.

HTTP 에러, 템플릿 기본 레이아웃 같은 것들은 별도의 resolution 과정을 거친다.
위와 거의 유사하지만 만약 맨 마지막에서 파일이 없을 경우 "다음" 디렉토리를 뒤져
본다는 점이 다르다고 생각하면 된다.

