## vim: syn=mako
<%! title = u'브레인퍽' %>


구현
====

브레인퍽은 언어 자체가 매우 간단하기 때문에 구현은 하루, 어쩌면 몇 분 안에도 가능합니다만, 최적화를 하기 시작하면 한도 끝도 없는 언어 중 하나이기도 합니다. 저는 현존하는 브레인퍽-C 컴파일러 중 가장 뛰어난 것으로 알려져 있는 [Esotope Brainfuck Compiler](/projects/esotope/bfc/)의 제작자입니다.


160바이트 C 인터프리터
----------------------

<small>(2010-09-25)</small> 진지한(?) 구현체와는 별개로, 그냥 재미 삼아 만들어 본 160바이트짜리 C 인터프리터입니다. 아마도 이 부류의 인터프리터 중에서는 가장 작은 것이라고 생각합니다. 눈꼽만큼 더 자세한 설명(영문)은 [저널](http://j.mearie.org/post/1181041789/brainfuck-interpreter-in-2-lines-of-c)을, 관련된 토론은 [레딧](http://www.reddit.com/r/programming/comments/djelv/brainfuck_interpreter_in_160_bytes_of_c/)을 참고하세요.

~~~~~~~~
s[99],*r=s,*d,c;main(a,b){char*v=1[d=b];for(;c=*v++%93;)for(b=c&2,b=c%7?a&&(c&17
?c&1?(*r+=b-1):(r+=b-1):syscall(4-!b,b,r,1),0):v;b&&c|a**r;v=d)main(!c,&a);d=v;}
~~~~~~~~

이 코드를 분석하려는 용자를 위한 힌트: 이 코드는 `[`..`]` 블록을 처리하기 위해서 `main` 함수를 재귀적으로 호출합니다. 함수의 첫번째 루프는 현재 `[`..`]` 블록 안의 코드를 실행하고, 두번째 루프는 현재 명령이 `[`일 때 루프를 실행하거나, 현재 셀이 0인 경우 다음 `]`로 넘어갈 때 사용합니다(처음 호출시에 `main` 함수의 첫 인자는 0이 될 수 없다는 사실을 악용합니다). `return` 문을 줄이기 위해 `d` 변수가 리턴값을 넣는 용도로 쓰였다는 점도 눈여겨 볼 필요가 있습니다.

