<%! title = u'메아리 프로젝트: 버섯' %>
<%!
def pre(s):
	return '<pre><![CDATA[' + s.strip('\n').replace(']]>',']]]>]<![CDATA[>') + ']]></pre>'
%>
<h1>버섯</h1>
<p><strong>버섯</strong>(Versert)은 <a href="/">강 성훈</a>이 만든 <a href="http://ko.wikipedia.org/wiki/%EB%B9%84%ED%8E%80%EC%A7%80">비펀지</a> 비스무리한 난해한 프로그래밍 언어입니다.</p>

<h2 id="history">역사</h2>
<p>버섯은 비펀지에서 스택을 빼면 뭐가 남을까 하는 의문에서 출발했습니다. 아이디어는 2005년 7월 10일에 만들어졌고, 2005년 7월 22일에 언어 명세와 구현을 공개하였습니다.</p>
<p>버섯은 영어로 균류를 나타내는 <em lang="en">fungi</em>에서 유래한 이름입니다. 정작 비펀지(Befunge) 자체는 균류와 별 관계 없지만, 발음이 비슷한 관계로 그냥 씁니다. 이 이름은 <a href="http://xtendo.org/">한 동성</a> 군의 도움으로 정해졌습니다.</p>

<h2 id="specification">명세</h2>

<h3 id="environment">환경</h3>
<p>비펀지와 마찬가지로 버섯은 2차원 프로그래밍 언어입니다. 2차원 프로그래밍 언어라 함은 C나 자바와 같은 일반적인 언어와는 달리 코드가 2차원으로 구성되어 있으며, 코드의 흐름이 한 방향이 아닐 수도 있다는 의미입니다.</p>
<p>모든 코드는 무한한 크기의 2차원 평면에 펼쳐집니다. 평면 상의 한 점에는 (열, 행) 형태의 좌표가 주어지며, 모든 코드는 정수 좌표를 가진 '칸'에 한 글자씩 저장됩니다. 한 칸에는 8비트 부호 없는 정수(0부터 255까지)가 하나 들어 갑니다. 원점인 (0, 0)은 코드 상으로 첫 줄, 맨 왼쪽 칸에 있는 문자에 해당합니다.</p>
<p>실행되기 전에 코드는 ASCII 문자로 읽혀서 (0, 0)부터 순서대로 저장됩니다. 빈 칸은 공백 문자, 즉 32라는 값이 들어 있는 것으로 간주합니다. 평면에 저장된 코드에는 처음에 개행 문자가 존재하지 않으며, 나중에 이 평면에 개행 문자에 해당하는 10과 같은 숫자를 넣는다고 해서 행이 바뀌지는 않습니다.</p>
<p>버섯은 스택을 사용하지 않습니다. 버섯 프로그램이 내부적으로 가지고 있는 상태는 다음과 같습니다.</p>
<dl>
	<dt>명령 포인터 IP = (<var>x</var>, <var>y</var>)</dt>
	<dd>코드 공간 상에서 현재 실행되고 있는 명령의 좌표를 가리킵니다. 프로그램이 시작하면 처음에 IP는 (0, 0)입니다.</dd>
	<dt>속도 delta = (<var>dx</var>, <var>dy</var>)</dt>
	<dd>IP가 움직이는 방향을 가리킵니다. IP가 가리키는 명령을 실행한 뒤 IP에 delta를 더해서 다음 명령으로 IP를 이동시킵니다. 처음에 delta는 (1, 0)으로, IP는 오른쪽으로 움직입니다.</dd>
	<dt>자료 포인터 DP = (<var>px</var>, <var>py</var>)</dt>
	<dd>코드 공간에서 값을 읽거나 쓸 때, 그 대상이 되는 칸의 좌표를 가리킵니다. 처음에 DP는 (0, 0)입니다.</dd>
	<dt>레지스터 <var>A</var>, <var>B</var></dt>
	<dd>명령이 직접적으로 변경할 수 있는 레지스터입니다. 처음에 A와 B의 값은 모두 0입니다.</dd>
</dl>
<p>비펀지와 마찬가지로, 코드 공간은 왼쪽 끝과 오른쪽 끝, 그리고 위쪽 끝과 아랫쪽 끝이 연결되어 있습니다. 즉 IP가 코드가 없는 바깥쪽으로 빠져 나가면 IP는 반대쪽으로 다시 돌아 오며, delta를 바꾸는 명령을 만나지 않는다면 항상 원래 위치로 돌아 옵니다. 이런 코드 공간의 특성은 흔히 Lahey 공간이라고 불립니다.</p>

<h3 id="instructions">명령 일람</h3>
<p>아래는 버섯이 지원하는 모든 명령의 목록입니다. 여기에 없는 명령은 공백과 같이 아무 일도 하지 않습니다.</p>
<table>
<thead>
	<tr><th>문자</th><th>의미</th><th>설명</th></tr>
</thead>
<tbody>
	<tr><th><code>0..9</code></th><td><pre>A ← 0..9</pre></td><td>A의 값을 지정한 숫자로 변경합니다.</td></tr>
	<tr><th><code>+</code></th><td><pre>B ← B + A</pre></td><td>B에 A의 값을 더합니다.</td></tr>
	<tr><th><code>-</code></th><td><pre>B ← B - A</pre></td><td>B에서 A의 값을 뺍니다.</td></tr>
	<tr><th><code>*</code></th><td><pre>B ← B × A</pre></td><td>B에 A의 값을 곱합니다.</td></tr>
	<tr><th><code>~</code></th><td><pre>A, B ← B, A</pre></td><td>A와 B의 값을 맞바꿉니다.</td></tr>
	<tr><th><code>&lt;</code></th><td><pre>if A &gt; B then<br />    A, B ← B, A</pre></td><td>A가 B보다 크면 A와 B의 값을 맞바꿉니다.</td></tr>
	<tr><th><code>&gt;</code></th><td><pre>if A &lt; B then<br />    A, B ← B, A</pre></td><td>A가 B보다 작으면 A와 B의 값을 맞바꿉니다.</td></tr>
	<tr><th><code>/</code></th><td><pre>dx, dy ← -dy, -dx</pre></td><td>IP가 오른쪽/아래/왼쪽/위로 오고 있었다면, 각각 위/왼쪽/아래/오른쪽으로 방향을 바꿉니다.</td></tr>
	<tr><th><code>\</code></th><td><pre>dx, dy ← dy, dx</pre></td><td>IP가 오른쪽/아래/왼쪽/위로 오고 있었다면, 각각 아래/오른쪽/위/왼쪽으로 방향을 바꿉니다.</td></tr>
	<tr><th><code>@</code></th><td><pre>exit()</pre></td><td>프로그램의 실행을 종료합니다.</td></tr>
	<tr><th><code>#</code></th><td><pre>if B = 0 then<br />    IP ← IP + delta</pre></td><td>B가 0이면, 다음에 실행할 명령을 하나 건너 뛰고 그 다음 명령을 실행합니다.</td></tr>
	<tr><th><code>.</code></th><td><pre>putchar(A)</pre></td><td>표준 출력에 A의 하위 8비트를 ASCII 문자로 출력합니다.</td></tr>
	<tr><th><code>:</code></th><td><pre>putint(A)</pre></td><td>표준 출력에 A의 값을 문자열로 출력합니다.</td></tr>
	<tr><th><code>,</code></th><td><pre>A ← getchar()</pre></td><td>표준 입력으로부터 문자를 입력받아, 그 ASCII 값을 A에 저장합니다. EOF 문자가 입력되면 A는 바뀌지 않습니다.</td></tr>
	<tr><th><code>;</code></th><td><pre>A ← getint()</pre></td><td>표준 입력으로부터 숫자를 입력받아, 그 값을 A에 저장합니다. EOF 문자가 입력되면 A는 바뀌지 않습니다.</td></tr>
	<tr><th><code>{</code></th><td><pre>B ← space[px, py]</pre></td><td>코드 공간 상에서 DP가 가리키는 명령의 ASCII 값을 B에 저장합니다.</td></tr>
	<tr><th><code>|</code></th><td><pre>px ← px + A<br />py ← py + B</pre></td><td>DP를 왼쪽으로 A, 아랫쪽으로 B만큼 이동시킵니다.</td></tr>
	<tr><th><code>}</code></th><td><pre>space[px, py] ← B</pre></td><td>코드 공간 상에서 DP가 가리키는 명령을 B의 하위 8비트에 해당하는 ASCII 문자로 바꿉니다.</td></tr>
</tbody>
</table>

<h2 id="examples">예제 코드</h2>
<p>다음은 그 유명한 "Hello, world!" 프로그램입니다. 네. 조금 꼼수를 씁니다. -_-;</p>
<%text filter="pre">
\"Hello, world!" program.
\3+5*0~|}-2+0~|#/{~.00\ 
         @.~*5+2\#{|1~/
</%text>
<p>꼼수를 쓰지 않는 정석 프로그램은 다음과 같습니다.</p>
<%text filter="pre">
6~6*}2*~.{+7-~.~7+~..~3+~.~{8+~.~{4-~.~4*9-~.~8-~.~3+~.~6-~.~8-~.~{3-~.~2~5*~.@
</%text>
<p>다음 프로그램은 EOF 문자가 나올 때까지 표준 입력을 읽어서 표준 출력으로 씁니다.</p>
<%text filter="pre">
#/#.0~1\
@\#+,~-/
</%text>
<p>다음 프로그램은 자기 자신을 그대로 출력합니다. (Thanks to <a href="http://www.frox25.no-ip.org/~mtve/code/eso/">mtve</a>)</p>
<%text filter="pre">
# #/ 0|   0~4+8*0~|}-0~|#/{~.00\
" @\# -2+{|~0*8-4~0.~*5+2\#{|1~/
</%text>

<h2 id="download">내려받기</h2>
<p><a href="http://svn.mearie.org/esolang/versert/versert.c">참조 구현</a>은 ISO C로 작성되었으며, 컴파일하고 인자로 파일 이름을 넣어서 실행할 수 있습니다.</p>

<p><a href="http://svn.mearie.org/esolang/versert/">서브버전 저장소</a>에는 버섯에 관련된 여러 자료가 들어 있습니다.</p>

## vim: syn=mako
