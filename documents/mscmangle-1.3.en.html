<h1><!--(-->Microsoft C++ Name Mangling Scheme<!--)--></h1>
<div id="metadata">
	<p>version 1.3 (July 9, 2007)<br />Kang Seonghoon</p>
</div>
<p>This document discusses C++ name mangling scheme used by Microsoft.</p>

<h2 id="intro">Introduction</h2>
<p>What is a name mangling scheme? This is a part of Application Binary Interface (ABI), specifies how to convert a bare &ndash; possibly qualified &ndash; C++ name into the encoded form.</p>
<p>Then why are they needed? One can think about two differently looking but same identifiers:</p>
<pre>
typedef int something;
const int func(something, int*);
const something func(int, something*);
</pre>
<p>Of course we could normalize these, but normalization will make them obscure and verbose. Name mangling scheme encodes the normalized form to compact string like <code>__Z4funciPi</code>. Because mangled forms of them are same, we conclude they are in turn same identifiers. More excellent descriptions are found in <a href="http://en.wikipedia.org/wiki/Name_mangling#Name_mangling_in_C.2B.2B">Wikipedia</a>.</p>
<p>Since shared object and Windows DLL exposes mangled C++ symbols, and different compilers use different schemes, we can take advantage when we know a compiler's mangling scheme. You can quickly google and get several well-known mangling scheme (including GNU g++'s one). Unfortunately there is no such thing for Microsoft C++, and I ended up with writing this document.</p>

<h3 id="intro-reference">Reference</h3>
<p>Microsoft's <a href="http://www.microsoft.com/whdc/devtools/debugging/default.mspx">DbgHelp library</a> contains <a href="http://msdn2.microsoft.com/en-us/library/ms681400.aspx">UnDecorateSymbolName</a> function, which decodes a mangled form into corresponding C++ syntax. This function is remaining as primary source of this document; I called this function repeatedly with various arguments and figured out the scheme.</p>
<p>Also I learned the basic scheme from the following sources:</p>
<ul>
	<li><a href="http://winehq.org/">Wine</a> has its own <a href="http://cvs.winehq.com/cvsweb/wine/dlls/msvcrt/undname.c">implementation</a> of UnDecorateSymbolName. It works but is not quite complete, for example function pointers.</li>
	<li><a href="http://sourceforge.net/projects/php-ms-demangle/">PHP UnDecorateSymbolName</a> is an independent and nearly complete implementation by Timo Stripf.</li>
	<li><a href="http://www.kegel.com/mangle.html">C++ Name Mangling/Demangling</a> by Dan Kegel</li>
</ul>
<p>This document contains various Microsoft extensions to C++, such as Managed C++. Browse <a href="http://msdn.microsoft.com/">MSDN</a> for more information.</p>

<h3 id="intro-document">About this document</h3>
<p>This document is written and maintained by <a href="http://mearie.org/">Kang Seonghoon</a>. If you want to discuss or correct this document then please contact me at &lt;lifthrasiir at gmail dot com&gt;. Note that my English is not so fluent and may be incorrect.</p>
<p>Personally I prefer to use g++ and don't have copies of Microsoft Visual Studio. So I cannot guarantee that Microsoft C++ generates these encoded forms indeed yet. Verifying and correcting this document is always welcome, and even encouraged.</p>
<p>There are several versions of this document, listed below:</p>
<dl>
	<dt><a href="http://mearie.org/documents/mscmangle-1.3">Version 1.3</a> (this version)</dt>
	<dd>Added <a href="#intro">Introduction</a> section, EBNF definition and so on. Also added Korean version.</dd>
	<dt><a href="http://mearie.org/documents/mscmangle-1.2">Version 1.2</a></dt>
	<dd>Added <a href="#element-name-nested">nested name</a>; added PHP UnDecorateSymbolName to the reference.</dd>
	<dt><a href="http://mearie.org/documents/mscmangle-1.1">Version 1.1</a></dt>
	<dd>Initial document.</dd>
</dl>
<p>Latest version of this document is always available at <a href="http://mearie.org/documents/mscmangle">http://mearie.org/documents/mscmangle</a>. This document is licensed under <a href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License version 1.2</a> or any later version published by the Free Software Foundation, without any invariant sections and cover texts.</p>

<h2 id="basic">Basic Structure</h2>
<p>In Microsoft C++ scheme, mangled C++ name starts with <code>?</code>(question mark). Since all mangled C name starts with alphanumeric characters, <code>@</code>(commercial at) or <code>_</code>(underscore), C++ name can be fully distinguished from C name.</p>
<p>Beside the question mark, you will see the following structure:</p>
<ul>
	<li>Prefix <code>?</code></li>
	<li><em>Optional:</em> prefix <code>@?</code>, giving <var>CV:</var> prefix to the name. <small>[TODO: What is this?]</small></li>
	<li><a href="#qualified-name">Qualified name</a></li>
	<li>Type information, one of <a href="#function-typeinfo">function's one</a> or <a href="#data-typeinfo">data's one</a></li>
</ul>

<hr />
<div class="note"><p>BELOW IS NOT COMPLETED blah blah</p></div>

<p>Structure of mangled name looks like this:</p>
<ul>
	<li>Prefix <code>?</code></li>
	<li><em>Optional:</em> Prefix <code>@?</code> <small>[TODO: what does <code>CV:</code> mean?]</small></li>
	<li><a href="#element-name">Qualified name</a></li>
	<li>Type information (see below)</li>
</ul>

<div class="note"><pre><![CDATA[
mangled-name ::= "?" qualified-name type-info
               | "?@?" qualified-name type-info

IDENTIFIER ::= [a-zA-Z0-9_$]+
]]></pre></div>

<h3 id="basic-function">Function</h3>
<p>Type information in function name generally looks like this:</p>
<ul>
	<li>Access level and function type</li>
	<li><em>Conditional:</em> <a href="#element-cvclass">CV-class modifier</a> of function, if non-static member function</li>
	<li><a href="#element-function">Function property</a></li>
</ul>

<h3 id="basic-data">Data</h3>
<p>Type information in data name looks like this:</p>
<ul>
	<li>Access level and storage class</li>
	<li><a href="#element-type">Data type</a></li>
	<li><a href="#element-cvclass">CV-class modifier</a></li>
</ul>

<h2 id="element">Elements</h2>
<p>Mangled name contains a lot of elements have to be discussed.</p>

<h3 id="element-name">Name</h3>
<p>Qualified name consists of the following fragments:</p>
<ul>
	<li>Basic name: one of <a href="#element-name-frag">name fragment</a> and <a href="#element-name-special">special name</a></li>
	<li>Qualification #1: one of <a href="#element-name-frag">name fragment</a>, <a href="#element-name-template">name with template arguments</a>, <a href="#element-name-nested">nested name</a>, <a href="#element-name-nsnum">numbered namespace</a> and <a href="#element-name-backref">back reference</a></li>
	<li>Qualification #2</li>
	<li>...</li>
	<li>Terminator <code>@</code></li>
</ul>
<div class="note"><pre><![CDATA[
qualified-name ::= basic-name qualification* "@"

basic-name ::= name-fragment | special-name
qualification ::= name-fragment | template-name | nested-name
                | numbered-namespace | back-reference
]]></pre></div>
<p>Qualification is written in reversed order. For example <var>myclass::nested::something</var> becomes <code>something@nested@myclass@@</code>.</p>

<h4 id="element-name-frag">Name Fragment</h4>
<p>A fragment of name is simply represented as the name with trailing <code>@</code>.</p>
<div class="note"><pre><![CDATA[
name-fragment ::= IDENTIFIER "@"
]]></pre></div>

<h4 id="element-name-special">Special Name</h4>
<p>Special name is represented as the code with preceding <code>?</code>. Most of special name is constructor, destructor, operator and internal symbol. Below is a table for known codes.</p>
<table>
<thead>
<tr><th>Code</th><th>Meaning with no <code>_</code></th><th>Meaning with preceding <code>_</code></th><th>Meaning with preceding two <code>_</code>s</th></tr>
</thead>
<tbody>
<tr><th><code>0</code></th><td>Constructor</td><td><var>operator/=</var></td></tr>
<tr><th><code>1</code></th><td>Destructor</td><td><var>operator%=</var></td></tr>
<tr><th><code>2</code></th><td><var>operator new</var></td><td><var>operator&gt;&gt;=</var></td></tr>
<tr><th><code>3</code></th><td><var>operator delete</var></td><td><var>operator&lt;&lt;=</var></td></tr>
<tr><th><code>4</code></th><td><var>operator=</var></td><td><var>operator&amp;=</var></td></tr>
<tr><th><code>5</code></th><td><var>operator&gt;&gt;</var></td><td><var>operator|=</var></td></tr>
<tr><th><code>6</code></th><td><var>operator&lt;&lt;</var></td><td><var>operator^=</var></td></tr>
<tr><th><code>7</code></th><td><var>operator!</var></td><td>`vftable'</td></tr>
<tr><th><code>8</code></th><td><var>operator==</var></td><td>`vbtable'</td></tr>
<tr><th><code>9</code></th><td><var>operator!=</var></td><td>`vcall'</td></tr>
<tr><th><code>A</code></th><td><var>operator[]</var></td><td>`typeof'</td><td>`managed vector constructor iterator'</td></tr>
<tr><th><code>B</code></th><td><var>operator <em>returntype</em></var><!--((-->Its meaning depends on return type of function. For instance, if this function returns <code>int</code> type then its name will be <var>operator int</var>.<!--))--></td><td>`local static guard'</td><td>`managed vector destructor iterator'</td></tr>
<tr><th><code>C</code></th><td><var>operator-&gt;</var></td><td>`string' <em>(Unknown)</em><!--((-->It seems structure after <code>?_C</code> is different from other structure. I think this structure is represented as regular expression <code>\?_C@_[0-9A-P]([0-9A-P][A-P]*)?@.*@</code>, but I'm not sure.<!--))--></td><td>`eh vector copy constructor iterator'</td></tr>
<tr><th><code>D</code></th><td><var>operator*</var></td><td>`vbase destructor'</td><td>`eh vector vbase copy constructor iterator'</td></tr>
<tr><th><code>E</code></th><td><var>operator++</var></td><td>`vector deleting destructor'</td></tr>
<tr><th><code>F</code></th><td><var>operator--</var></td><td>`default constructor closure'</td></tr>
<tr><th><code>G</code></th><td><var>operator-</var></td><td>`scalar deleting destructor'</td></tr>
<tr><th><code>H</code></th><td><var>operator+</var></td><td>`vector constructor iterator'</td></tr>
<tr><th><code>I</code></th><td><var>operator&amp;</var></td><td>`vector destructor iterator'</td></tr>
<tr><th><code>J</code></th><td><var>operator-&gt;*</var></td><td>`vector vbase constructor iterator'</td></tr>
<tr><th><code>K</code></th><td><var>operator/</var></td><td>`virtual displacement map'</td></tr>
<tr><th><code>L</code></th><td><var>operator%</var></td><td>`eh vector constructor iterator'</td></tr>
<tr><th><code>M</code></th><td><var>operator&lt;</var></td><td>`eh vector destructor iterator'</td></tr>
<tr><th><code>N</code></th><td><var>operator&lt;=</var></td><td>`eh vector vbase constructor iterator'</td></tr>
<tr><th><code>O</code></th><td><var>operator&gt;</var></td><td>`copy constructor closure'</td></tr>
<tr><th><code>P</code></th><td><var>operator&gt;=</var></td><td>`udt returning' <em>(prefix)</em></td></tr>
<tr><th><code>Q</code></th><td><var>operator,</var></td><td><em>Unknown</em><!--((-->It can be EH-related code, but <var>UnDecorateSymbolName</var> function cannot demangle this.<!--))--></td></tr>
<tr><th><code>R</code></th><td><var>operator()</var></td><td><em>RTTI-related code (see below)</em></td></tr>
<tr><th><code>S</code></th><td><var>operator~</var></td><td>`local vftable'</td></tr>
<tr><th><code>T</code></th><td><var>operator^</var></td><td>`local vftable constructor closure'</td></tr>
<tr><th><code>U</code></th><td><var>operator|</var></td><td><var>operator new[]</var></td></tr>
<tr><th><code>V</code></th><td><var>operator&amp;&amp;</var></td><td><var>operator delete[]</var></td></tr>
<tr><th><code>W</code></th><td><var>operator||</var></td></tr>
<tr><th><code>X</code></th><td><var>operator*=</var></td><td>`placement delete closure'</td></tr>
<tr><th><code>Y</code></th><td><var>operator+=</var></td><td>`placement delete[] closure'</td></tr>
<tr><th><code>Z</code></th><td><var>operator-=</var></td></tr>
</tbody>
</table>
<p>Prefix <code>_P</code> is used as <code>?_PX</code>, though I don't know about it. <small>[TODO: what is udt? user defined type?]</small></p>
<p>Below is RTTI-related code (all starting with <code>_R</code>). Some codes have trailing parameters.</p>
<table>
<thead>
<tr><th>Code</th><th>Meaning</th><th>Trailing Parameters</th></tr>
</thead>
<tbody>
<tr><th><code>_R0</code></th><td><em>type</em> `RTTI Type Descriptor'</td><td><a href="#element-type">Data type</a> <em>type</em>.</td></tr>
<tr><th><code>_R1</code></th><td>`RTTI Base Class Descriptor at (<em>a</em>,<em>b</em>,<em>c</em>,<em>d</em>)'</td><td>Four <a href="#element-number">encoded numbers</a> <em>a</em>, <em>b</em>, <em>c</em> and <em>d</em>.</td></tr>
<tr><th><code>_R2</code></th><td>`RTTI Base Class Array'</td><td>None.</td></tr>
<tr><th><code>_R3</code></th><td>`RTTI Class Hierarchy Descriptor'</td><td>None.</td></tr>
<tr><th><code>_R4</code></th><td>`RTTI Complete Object Locator'</td><td>None.</td></tr>
</tbody>
</table>
<div class="note"><pre><![CDATA[
special-name ::= simple-special-name | string-name | udt-returning-name
               | possibly-eh-related-name | rtti-related-name

simple-special-name ::= [0-9A-Z] | "_" [0-9ABD-OS-VXY] | "__" [A-D]
string-name ::= /* unknown */
udt-returning-name ::= "_P" data-type
possibly-eh-related-name ::= /* unknown */
rtti-related-name ::= "_R0" data-type
		    | "_R1" number number number number number
                    | "_R" [2-4]
]]></pre></div>

<h4 id="element-name-template">Name with Template Arguments</h4>
<p>Name fragment starting with <code>?$</code> has template arguments. This kind of name looks like this:</p>
<ul>
	<li>Prefix <code>?$</code></li>
	<li>Name terminated by <code>@</code></li>
	<li><a href="#element-arglist-template">Template argument list</a></li>
</ul>
<div class="note"><pre><![CDATA[
template-name ::= "?$" name-fragment template-argument-list
]]></pre></div>
<p>For example, we assume the following prototype.</p>
<pre>void __cdecl abc&lt;def&lt;int&gt;,void*&gt;::xyz(void);</pre>
<p>Name of this function can be obtained by the following process:</p>
<pre>
<em>abc&lt;def&lt;int&gt;,void*&gt;::xyz</em>
xyz@ <em>abc&lt;def&lt;int&gt;,void*&gt;</em> @
xyz@ ?$abc@ <em>def&lt;int&gt;</em> <em>void*</em> @ @
xyz@ ?$abc@ V <em>def&lt;int&gt;</em> @ PAX @ @
xyz@ ?$abc@ V ?$def@H@ @ PAX @ @
<strong>xyz@?$abc@V?$def@H@@PAX@@</strong>
</pre>
<p>So mangled name for this function is <code>?<strong>xyz@?$abc@V?$def@H@@PAX@@</strong>YAXXZ</code>.</p>

<h4 id="element-name-nested">Nested Name</h4>
<p>Name fragment starting with <code>??</code> denotes nested name. Nested name is a name inside local scope but needed to be exported. Its structure looks like the following:</p>
<ul>
	<li>Prefix <code>?</code></li>
	<li>C++ Mangled name (so starting with <code>?</code> again)</li>
</ul>
<div class="note"><pre><![CDATA[
nested-name ::= "?" mangled-name
]]></pre></div>
<p>For example, <code>?nested@??func@@YAXXZ@4HA</code> means variable <code>?nested@@4HA</code>(<var>int nested</var>) inside <code>?func@@YAXXZ</code>(<var>void __cdecl func(void)</var>). <var>UnDecorateSymbolName</var> function returns <var>int `void __cdecl func(void)'::nested</var> for this input.</p>

<h4 id="element-name-nsnum">Numbered Namespace</h4>
<p>In qualification, numbered namespace is represented as preceding <code>?</code> and unsigned <a href="#element-number">number</a>. <var>UnDecorateSymbolName</var> function returns something like <var>`42'</var> for this kind of input.</p>
<p>Exceptionally if numbered namespace starts with <code>?A</code> it becomes anonymous namespace (<var>`anonymous namespace'</var>).</p>
<div class="note"><pre><![CDATA[
numbered-namespace ::= "?" number
]]></pre></div>
<p>Well, of course I'm not sure what it is. <small>[TODO: what is exact meaning and name? I don't think its name is really "numbered namespace".]</small></p>

<h4 id="element-name-backref">Back Reference</h4>
<p>Decimal digits <code>0</code> to <code>9</code> refers to first shown name fragment to 10th shown name fragment. Referred name fragment can be normal name fragment or name fragment with template arguments. For example, in <code>alpha@?1beta@@</code>(<var>beta::`2'::alpha</var>) <code>0</code> refers to <code>alpha@</code>, and <code>1</code>(not <code>2</code>) refers to <code>beta@</code>.</p>
<div class="note"><pre><![CDATA[
back-reference ::= [0-9]
]]></pre></div>
<p>Generally back reference table is kept during mangling process. It means you can use back reference to function name in function arguments (shown later than function name). However, in <a href="#element-arglist-template">template argument list</a> back reference table is separately created.</p>
<p>For example, assume <code>?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@<strong>2</strong>@@std@@</code>&#8203;(<var>std::basic_string&lt;unsigned short, std::char_traits&lt;unsigned short&gt;, <strong>std</strong>::allocator&lt;unsigned short&gt; &gt;</var>). In <code>std::basic_string&lt;...&gt;</code>, <code>0</code> refers to <code>basic_string@</code>, <code>1</code> refers to <code>?$char_traits@G@</code>, and <code>2</code> refers to <code>std@</code>. This relation doesn't change wherever it is.</p>

<h3 id="element-number">Encoded Number</h3>
<p>In name mangling, representation of number is needed sometimes (e.g. array indices). There are simple rules to represent number:</p>
<ul>
	<li><code>0</code> to <code>9</code> represents number 1 to 10.</li>
	<li><code><em>num</em>@</code> represents hexadecimal number, where <em>num</em> consists of hexadecimal digit <code>A</code>(means 0) to <code>P</code>(means 15). For example <code>BCD@</code> means number 0x123, that is 291.</li>
	<li><code>@</code> represents number 0.</li>
	<li>If allowed, prefix <code>?</code> represents minus sign. Note that both <code>?@</code> and <code>@</code> represents number 0.</li>
</ul>
<div class="note"><pre><![CDATA[
number ::= short-number | long-number
short-number ::= [0-9]
long-number ::= number-sign [A-P]* "@"
number-sign ::= "?"?
]]></pre></div>

<h3 id="element-type">Data Type</h3>
<p>The table below shows various data type and modifiers.</p>
<table>
<thead>
<tr><th>Code</th><th>Meaning with no <code>_</code></th><th>Meaning with preceding <code>_</code></th></tr>
</thead>
<tbody>
<tr><th>?</th><td><em>Type modifier, Template parameter</em></td></tr>
<tr><th>$</th><td><em>Type modifier, Template parameter</em><!--((-->There is <code>$$B</code> prefix, but it seems that this prefix can be ignored.<!--))--></td><td>__w64 <em>(prefix)</em></td></tr>
<tr><th>0-9</th><td><em>Back reference</em></td></tr>
<tr><th>A</th><td><em>Type modifier (reference)</em></td></tr>
<tr><th>B</th><td><em>Type modifier (volatile reference)</em></td></tr>
<tr><th>C</th><td>signed char</td></tr>
<tr><th>D</th><td>char</td><td>__int8</td></tr>
<tr><th>E</th><td>unsigned char</td><td>unsigned __int8</td></tr>
<tr><th>F</th><td>short</td><td>__int16</td></tr>
<tr><th>G</th><td>unsigned short</td><td>unsigned __int16</td></tr>
<tr><th>H</th><td>int</td><td>__int32</td></tr>
<tr><th>I</th><td>unsigned int</td><td>unsigned __int32</td></tr>
<tr><th>J</th><td>long</td><td>__int64</td></tr>
<tr><th>K</th><td>unsigned long</td><td>unsigned __int64</td></tr>
<tr><th>L</th><td></td><td>__int128</td></tr>
<tr><th>M</th><td>float</td><td>unsigned __int128</td></tr>
<tr><th>N</th><td>double</td><td>bool</td></tr>
<tr><th>O</th><td>long double</td><td><em>Array</em></td></tr>
<tr><th>P</th><td><em>Type modifier (pointer)</em></td></tr>
<tr><th>Q</th><td><em>Type modifier (const pointer)</em></td></tr>
<tr><th>R</th><td><em>Type modifier (volatile pointer)</em></td></tr>
<tr><th>S</th><td><em>Type modifier (const volatile pointer)</em></td></tr>
<tr><th>T</th><td><em>Complex Type (union)</em></td></tr>
<tr><th>U</th><td><em>Complex Type (struct)</em></td></tr>
<tr><th>V</th><td><em>Complex Type (class)</em></td></tr>
<tr><th>W</th><td><em>Enumerate Type (enum)</em></td><td>wchar_t</td></tr>
<tr><th>X</th><td>void, <em>Complex Type (coclass)</em></td><td><em>Complex Type (coclass)</em></td></tr>
<tr><th>Y</th><td><em>Complex Type (cointerface)</em></td><td><em>Complex Type (cointerface)</em></td></tr>
<tr><th>Z</th><td>... <em>(elipsis)</em></td></tr>
</tbody>
</table>
<p>Actually void for <code>X</code> and elipsis for <code>Z</code> can be used only for terminator of <a href="#element-arglist">argument list</a> or pointer. Otherwise, <code>X</code> is used as cointerface.</p>
<div class="note"><pre><![CDATA[
data-type ::= simple-data-type | back-reference | reference-type
	    | pointer-type | complex-type | enumerate-type
            | variable-sized-type | array-type
]]></pre></div>

<h4 id="element-type-primitive">Primitive &amp; Extended Type</h4>
<p>Primitive types are represented as one character, and extended types are represented as one character preceding <code>_</code>.</p>

<h4 id="element-type-backref">Back Reference</h4>
<p>Decimal digits <code>0</code> to <code>9</code> refers to first shown type to 10th shown type in argument list. (It means return type cannot be referred.) Back reference can refer to any non-primitive type, including extended type. Of course back reference can refer to prefixed type such as <code>PAVblah@@</code>(<var>class blah *</var>), but cannot refer to prefixless type &mdash; say, <code>Vblah@@</code> in <code>PAVblah@@</code>.</p>
<p>As back reference for name, in <a href="#element-arglist-template">template argument list</a> back reference table is separately created. Function argument list has no such scoping rule, though it can be confused sometimes. For example, assume <code>P6AXValpha@@Vbeta@@@Z</code>(<var>void (__cdecl*)(class alpha, class beta)</var>) is first shown non-primitive type. Then <code>0</code> refer to <code>Valpha@@</code>, <code>1</code> refer to <code>Vbeta@@</code>, and finally <code>2</code> refer to function pointer.</p>

<h4 id="element-type-typemod">Type Modifier</h4>
<p>Type modifier is used to make pointer or reference. Type modifier looks like this:</p>
<ul>
	<li>Modifier type</li>
	<li><em>Optional:</em> Managed C++ property (<code>$A</code> for __gc, <code>$B</code> for __pin)</li>
	<li><a href="#element-cvclass">CV-class modifier</a></li>
	<li><em>Optional:</em> Array property (not for function)<ul>
		<li>Prefix <code>Y</code></li>
		<li><a href="#element-number">Encoded unsigned number</a> of dimension</li>
		<li>Array indices as encoded unsigned number, <em>dimension</em> times</li>
	</ul></li>
	<li>Referred type info (see below)</li>
</ul>
<p>There is eight type of type modifier:</p>
<table class="centered-cell">
<thead>
<tr><th></th><th><em>none</em></th><th>const</th><th>volatile</th><th>const volatile</th></tr>
</thead>
<tbody>
<tr><th>Pointer</th><td><code>P</code></td><td><code>Q</code></td><td><code>R</code></td><td><code>S</code></td></tr>
<tr><th>Reference</th><td><code>A</code></td><td></td><td><code>B</code></td><td></td></tr>
<tr><th><em>none</em></th><td><code>?</code><!--((--><code>?</code> is valid only for type of <a href="#data">data</a>. Also <code>?</code> should be the outmost type modifier. (<code>?CPB</code> is valid but <code>PB?C</code> is not.)<!--))-->, <code>$$C</code></td></tr>
</tbody>
</table>
<p>For normal type, referred type info is <a href="#element-type">data type</a>. For function, it looks like the following. (It depends on CV-class modifier)</p>
<ul>
	<li><em>Conditional:</em> <a href="#element-cvclass">CV-class modifier</a>, if member function</li>
	<li><a href="#element-function">Function property</a></li>
</ul>

<h4 id="element-type-aggregate">Complex Type (union, struct, class, coclass, cointerface)</h4>
<p>Complex type looks like this:</p>
<ul>
	<li>Kind of complex type (<code>T</code>, <code>U</code>, <code>V</code>, ...)<!--((--><code>?</code> and <code>L</code> can be complex type without any tag such as class, but it can also be a bug of the function.<!--))--></li>
	<li><a href="#element-name">Qualification without basic name</a></li>
</ul>

<h4 id="elemene-type-enum">Enumerate Type (enum)</h4>
<p>Enumerate type starts with prefix <code>W</code>. It looks like this:</p>
<ul>
	<li>Prefix <code>W</code></li>
	<li>Real type for enum</li>
	<li><a href="#element-name">Qualification without basic name</a></li>
</ul>
<p>Real type for enum is represented as the following:</p>
<table>
<thead>
<tr><th>Code</th><th>Corresponding Real Type</th></tr>
</thead>
<tbody>
<tr><th><code>0</code></th><td>char</td></tr>
<tr><th><code>1</code></th><td>unsigned char</td></tr>
<tr><th><code>2</code></th><td>short</td></tr>
<tr><th><code>3</code></th><td>unsigned short</td></tr>
<tr><th><code>4</code></th><td>int <em>(generally normal "enum")</em></td></tr>
<tr><th><code>5</code></th><td>unsigned int</td></tr>
<tr><th><code>6</code></th><td>long</td></tr>
<tr><th><code>7</code></th><td>unsigned long</td></tr>
</tbody>
</table>

<h4 id="elemene-type-array">Array</h4>
<p>Array (not pointer to array!) starts with prefix <code>_O</code>. It looks like this:</p>
<ul>
	<li>Prefix <code>_O</code></li>
	<li><a href="#element-cvclass">CV-class modifier</a></li>
	<li><a href="#element-type">Data type</a> within array</li>
</ul>
<p>You can use multi-dimensional array like <code>_OC_OBH</code>, but only the outmost CV-class modifier is affected. (In this case <code>_OC_OBH</code> means <var>int volatile [][]</var>, not <var>int const [][]</var>)</p>

<h4 id="elemene-type-template">Template Parameter</h4>
<p>Template parameter is used to represent type and non-type template argument. It can be used in only <a href="#element-arglist-template">template argument list</a>.</p>
<p>The table below is a list of known template parameters. <em>a</em>, <em>b</em>, <em>c</em> represent <a href="#element-number">encoded signed numbers</a>, and <em>x</em>, <em>y</em>, <em>z</em> represent <a href="#element-number">encoded unsigned numbers</a>.</p>
<table>
<thead>
<tr><th>Code</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><th><code>?<em>x</em></code></th><td>anonymous type template parameter <em>x</em> (<var>`template-parameter-<em>x</em>'</var>)</td></tr>
<tr><th><code>$0<em>a</em></code></th><td>integer value <em>a</em></td></tr>
<tr><th><code>$2<em>a</em><em>b</em></code></th><td>real value <em>a</em> &times; 10<sup><em>b</em>-<em>k</em>+1</sup>, where <em>k</em> is number of decimal digits of <em>a</em><!--((-->For example, <code>$2HKLH@?2</code> means 3.1415 &times; 10<sup>-3</sup> = 0.0031415, because <code>HKLH@</code> means 31415 and <code>?2</code> means -3.<!--))--></td></tr>
<tr><th><code>$D<em>a</em></code></th><td>anonymous type template parameter <em>a</em> (<var>`template-parameter<em>a</em>'</var>)</td></tr>
<tr><th><code>$F<em>a</em><em>b</em></code></th><td>2-tuple {<em>a</em>,<em>b</em>} <em>(unknown)</em></td></tr>
<tr><th><code>$G<em>a</em><em>b</em><em>c</em></code></th><td>3-tuple {<em>a</em>,<em>b</em>,<em>c</em>} <em>(unknown)</em></td></tr>
<tr><th><code>$H<em>x</em></code></th><td><em>(unknown)</em></td></tr>
<tr><th><code>$I<em>x</em><em>y</em></code></th><td><em>(unknown)</em></td></tr>
<tr><th><code>$J<em>x</em><em>y</em><em>z</em></code></th><td><em>(unknown)</em></td></tr>
<tr><th><code>$Q<em>a</em></code></th><td>anonymous non-type template parameter <em>a</em> (<var>`non-type-template-parameter<em>a</em>'</var>)</td></tr>
</tbody>
</table>

<h3 id="element-arglist">Argument List</h3>
<p>Argument list is a sequence of <a href="#element-type">data types</a>. List can be one of the following:</p>
<ul>
	<li><code>X</code> (means <var>void</var>, also terminating list)</li>
	<li><em>arg1</em> <em>arg2</em> ... <em>argN</em> <code>@</code> (means normal list of data types. Note that N can be zero)</li>
	<li><em>arg1</em> <em>arg2</em> ... <em>argN</em> <code>Z</code> (means list with trailing elipsis)</li>
</ul>

<h4 id="element-arglist-template">Template Argument List</h4>
<p>Template argument list is same to argument list, except <a href="#element-type-template">template parameters</a> can be used.</p>

<h3 id="element-cvclass">CV-class Modifier</h3>
<p>The following table shows CV-class modifiers.<!--((-->Some tables contain two or more entries in one case. In this case, I tried to place more frequently used entry in the front. (But I'm not sure that this placement. Don't ask it for me!)<!--))--></p>
<table class="centered-cell">
<thead>
<tr><th rowspan="2"></th><th colspan="4">Variable</th><th rowspan="2">Function</th></tr>
<tr><td><em>none</em></td><td>const</td><td>volatile</td><td>const volatile</td></tr>
</thead>
<tbody>
<tr><th><em>none</em></th><td><code>A</code></td><td><code>B</code>, <code>J</code></td><td><code>C</code>, <code>G</code>, <code>K</code></td><td><code>D</code>, <code>H</code>, <code>L</code></td><td><code>6</code>, <code>7</code></td></tr>
<tr><th>__based()</th><td><code>M</code></td><td><code>N</code></td><td><code>O</code></td><td><code>P</code></td><td><code>_A</code>, <code>_B</code></td></tr>
<tr><th>Member</th><td><code>Q</code>, <code>U</code>, <code>Y</code></td><td><code>R</code>, <code>V</code>, <code>Z</code></td><td><code>S</code>, <code>W</code>, <code>0</code></td><td><code>T</code>, <code>X</code>, <code>1</code></td><td><code>8</code>, <code>9</code></td></tr>
<tr><th>__based() Member</th><td><code>2</code></td><td><code>3</code></td><td><code>4</code></td><td><code>5</code></td><td><code>_C</code>, <code>_D</code></td></tr>
</tbody>
</table>
<p>CV-class modifier can have zero or more prefix:</p>
<table>
<thead>
<tr><th>Prefix</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><th><code>E</code></th><td><em>type</em> __ptr64</td></tr>
<tr><th><code>F</code></th><td>__unaligned <em>type</em></td></tr>
<tr><th><code>I</code></th><td><em>type</em> __restrict</td></tr>
</tbody>
</table>
<p>Modifiers have trailing parameters as follows:</p>
<ul>
	<li><em>Conditional:</em> <a href="#element-name">Qualification without basic name</a>, if member</li>
	<li><em>Conditional:</em> <a href="#element-cvclass">CV-class modifier</a> of function, if member function</li>
	<li><em>Conditional:</em> <a href="#element-basedprop">__based() property</a>, if used</li>
</ul>
<p>CV-class modifier is usually used in reference/pointer type, but it is also used in other place with some restrictions:</p>
<ul>
	<li>Modifier of function: can only have const, volatile attribute, optionally with prefixes.</li>
	<li>Modifier of data: cannot have function property.</li>
</ul>

<h3 id="element-basedprop">__based() Property</h3>
<p>__based() property represents Microsoft's __based() attribute extension to C++. This property can be one of the following:</p>
<ul>
	<li><code>0</code> (means <var>__based(void)</var>)</li>
	<li><code>2<em>name</em></code> (means <var>__based(<em>name</em>)</var>, where <em>name</em> is <a href="#element-name">qualification without basic name</a>)</li>
	<li><code>5</code> (means no <var>__based()</var>)</li>
</ul>

<h3 id="element-function">Function Property</h3>
<p>Function property represents prototype of function. It looks like this:</p>
<ul>
	<li>Calling convention of function</li>
	<li><a href="#element-type">Data type</a> of returned value, or <code>@</code> for void</li>
	<li><a href="#element-arglist">Argument list</a></li>
	<li>throw() attribute</li>
</ul>
<p>The following table shows calling convention of function:</p>
<table class="centered-cell">
<thead>
<tr><th>Code</th><th>Exported?</th><th>Calling Convention</th></tr>
</thead>
<tbody>
<tr><th><code>A</code></th><td>No</td><td>__cdecl</td></tr>
<tr><th><code>B</code></th><td>Yes</td><td>__cdecl</td></tr>
<tr><th><code>C</code></th><td>No</td><td>__pascal</td></tr>
<tr><th><code>D</code></th><td>Yes</td><td>__pascal</td></tr>
<tr><th><code>E</code></th><td>No</td><td>__thiscall</td></tr>
<tr><th><code>F</code></th><td>Yes</td><td>__thiscall</td></tr>
<tr><th><code>G</code></th><td>No</td><td>__stdcall</td></tr>
<tr><th><code>H</code></th><td>Yes</td><td>__stdcall</td></tr>
<tr><th><code>I</code></th><td>No</td><td>__fastcall</td></tr>
<tr><th><code>J</code></th><td>Yes</td><td>__fastcall</td></tr>
<tr><th><code>K</code></th><td>No</td><td><em>none</em></td></tr>
<tr><th><code>L</code></th><td>Yes</td><td><em>none</em></td></tr>
<tr><th><code>M</code></th><td>No</td><td>__clrcall</td></tr>
</tbody>
</table>
<p>Argument list for throw() attribute is same to <a href="#element-arglist">argument list</a>, but if this list is <code>Z</code>, it means there is no throw() attribute. If you want to use <var>throw()</var> you have to use <code>@</code> instead.</p>

<h2 id="function">Function</h2>
<p>Typical type information in function name looks like this:</p>
<ul>
	<li><em>Optional:</em> Prefix <code>_</code> (means __based() property is used)</li>
	<li>Access level and function type</li>
	<li><em>Conditional:</em> <a href="#element-basedprop">__based() property</a>, if used</li>
	<li><em>Conditional:</em> adjustor property (as <a href="#element-number">encoded unsigned number</a>), if thunk function</li>
	<li><em>Conditional:</em> <a href="#element-cvclass">CV-class modifier</a> of function, if non-static member function</li>
	<li><a href="#element-function">Function property</a></li>
</ul>
<p>The table below shows code for access level and function type:</p>
<table class="centered-cell">
<thead>
<tr><th></th><th><em>none</em></th><th>static</th><th>virtual</th><th>thunk</th></tr>
</thead>
<tbody>
<tr><th>private:</th><td><code>A</code>, <code>B</code></td><td><code>C</code>, <code>D</code></td><td><code>E</code>, <code>F</code></td><td><code>G</code>, <code>H</code></td></tr>
<tr><th>protected:</th><td><code>I</code>, <code>J</code></td><td><code>K</code>, <code>L</code></td><td><code>M</code>, <code>N</code></td><td><code>O</code>, <code>P</code></td></tr>
<tr><th>public:</th><td><code>Q</code>, <code>R</code></td><td><code>S</code>, <code>T</code></td><td><code>U</code>, <code>V</code></td><td><code>W</code>, <code>X</code></td></tr>
<tr><th><em>none</em></th><td><code>Y</code>, <code>Z</code></td></tr>
</tbody>
</table>
<p>This kind of thunk function is always virtual, and used to represent logical <var>this</var> adjustor property, which means an offset to true <var>this</var> value in some multiple inheritance.</p>

<h2 id="data">Data</h2>
<p>Type information in data name looks like this:</p>
<ul>
	<li>Access level and storage class</li>
	<li><a href="#element-type">Data type</a></li>
	<li><a href="#element-cvclass">CV-class modifier</a></li>
</ul>
<p>The table below shows code for access level and storage class:</p>
<table>
<thead>
<tr><th>Code</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><th><code>0</code></th><td>Private static member</td></tr>
<tr><th><code>1</code></th><td>Protected static member</td></tr>
<tr><th><code>2</code></th><td>Public static member</td></tr>
<tr><th><code>3</code></th><td>Normal variable</td></tr>
<tr><th><code>4</code></th><td>Normal variable</td></tr>
</tbody>
</table>
<p>CV-class modifier should not be function.</p>

<h2 id="thunkfunction">Thunk Function</h2>
<p>There is several kind of thunk function. <small>[TODO: a lot of thunk function!]</small></p>

