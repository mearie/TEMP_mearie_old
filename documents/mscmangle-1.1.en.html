<h1><!--(-->Microsoft C++ Name Mangling Scheme<!--)--></h1>
<div id="metadata">
	<p>version 1.1 (November 25, 2005)</p>
</div>
<p>This document discusses C++ name mangling scheme used by Microsoft. I think this is the most complete document about this scheme currently.</p>

<h3 id="top-author">Author</h3>
<p>This document is maintained by <a href="http://tokigun.net/">Kang Seonghoon</a> aka Tokigun.</p>
<p>If you want to discuss about this scheme or document please mail me: <tt>&lt;xxxxxxx at gmail dot com&gt;</tt> where xxxxxxx is tokigun.</p>
<p>And sorry for my poor English ;)</p>

<h3 id="top-reference">Reference</h3>
<p>Even though I could disassemble dbghelp.dll(or msvcrt.dll), I didn't do it because of the legal issues. So I used only <var>UnDecorateSymbolName</var> function to analysis this scheme.</p>
<p>Also I learned the basic scheme from the following source:</p>
<ul>
	<li><a href="http://winehq.org/">wine</a>'s <var>__unDname</var> function implementation (see <a href="http://cvs.winehq.com/cvsweb/wine/dlls/msvcrt/undname.c">/wine/dlls/msvcrt/undname.c</a>)</li>
	<li><a href="http://www.kegel.com/mangle.html">http://www.kegel.com/mangle.html</a></li>
</ul>
<p>Some feature of this scheme depends on Microsoft's C++ extension, such as Managed C++. Browse <a href="http://msdn.microsoft.com/">MSDN</a> for more information.</p>

<h2 id="basic">Basic Structure</h2>
<p>As you know, all mangled C++ name starts with <code>?</code>. Because all mangled C name starts with alphanumeric characters, <code>@</code>(at-sign) and <code>_</code>(underscore), C++ name can be distinguished from C name.</p>
<p>Structure of mangled name looks like this:</p>
<ul>
	<li>Prefix <code>?</code></li>
	<li><em>Optional:</em> Prefix <code>@?</code> <small>[TODO: what does <code>CV:</code> mean?]</small></li>
	<li><a href="#element-name">Qualified name</a></li>
	<li>Type information (see below)</li>
</ul>

<h3 id="basic-function">Function</h3>
<p>Type information in function name generally looks like this:</p>
<ul>
	<li>Access level and function type</li>
	<li><em>Conditional:</em> <a href="#element-cvclass">CV-class modifier</a> of function, if non-static member function</li>
	<li><a href="#element-function">Function property</a></li>
</ul>

<h3 id="basic-data">Data</h3>
<p>Type information in data name looks like this:</p>
<ul>
	<li>Access level and storage class</li>
	<li><a href="#element-type">Data type</a></li>
	<li><a href="#element-cvclass">CV-class modifier</a></li>
</ul>

<h2 id="element">Elements</h2>
<p>Mangled name contains a lot of elements have to be discussed.</p>

<h3 id="element-name">Name</h3>
<p>Qualified name consists of the following fragments:</p>
<ul>
	<li>Basic name: one of <a href="#element-name-frag">name fragment</a> and <a href="#element-name-special">special name</a></li>
	<li>Qualification #1: one of <a href="#element-name-frag">name fragment</a>, <a href="#element-name-template">name with template arguments</a>, <a href="#element-name-nsnum">numbered namespace</a> and <a href="#element-name-backref">back reference</a></li>
	<li>Qualification #2</li>
	<li>...</li>
	<li>Terminator <code>@</code></li>
</ul>
<p>Qualification is written in reversed order. For example <var>myclass::nested::something</var> becomes <code>something@nested@myclass@@</code>.</p>

<h4 id="element-name-frag">Name Fragment</h4>
<p>A fragment of name is simply represented as the name with trailing <code>@</code>.</p>

<h4 id="element-name-special">Special Name</h4>
<p>Special name is represented as the code with preceding <code>?</code>. Most of special name is constructor, destructor, operator and internal symbol. Below is a table for known codes.</p>
<table>
<thead>
<tr><th>Code</th><th>Meaning with no <code>_</code></th><th>Meaning with preceding <code>_</code></th><th>Meaning with preceding two <code>_</code>s</th></tr>
</thead>
<tbody>
<tr><th><code>0</code></th><td>Constructor</td><td><var>operator/=</var></td></tr>
<tr><th><code>1</code></th><td>Destructor</td><td><var>operator%=</var></td></tr>
<tr><th><code>2</code></th><td><var>operator new</var></td><td><var>operator&gt;&gt;=</var></td></tr>
<tr><th><code>3</code></th><td><var>operator delete</var></td><td><var>operator&lt;&lt;=</var></td></tr>
<tr><th><code>4</code></th><td><var>operator=</var></td><td><var>operator&amp;=</var></td></tr>
<tr><th><code>5</code></th><td><var>operator&gt;&gt;</var></td><td><var>operator|=</var></td></tr>
<tr><th><code>6</code></th><td><var>operator&lt;&lt;</var></td><td><var>operator^=</var></td></tr>
<tr><th><code>7</code></th><td><var>operator!</var></td><td>`vftable'</td></tr>
<tr><th><code>8</code></th><td><var>operator==</var></td><td>`vbtable'</td></tr>
<tr><th><code>9</code></th><td><var>operator!=</var></td><td>`vcall'</td></tr>
<tr><th><code>A</code></th><td><var>operator[]</var></td><td>`typeof'</td><td>`managed vector constructor iterator'</td></tr>
<tr><th><code>B</code></th><td><var>operator <em>returntype</em></var><sup><a id="footnoter1" href="#footnote1">[1]</a></sup></td><td>`local static guard'</td><td>`managed vector destructor iterator'</td></tr>
<tr><th><code>C</code></th><td><var>operator-&gt;</var></td><td>`string' <em>(Unknown)</em><sup><a id="footnoter2" href="#footnote2">[2]</a></sup></td><td>`eh vector copy constructor iterator'</td></tr>
<tr><th><code>D</code></th><td><var>operator*</var></td><td>`vbase destructor'</td><td>`eh vector vbase copy constructor iterator'</td></tr>
<tr><th><code>E</code></th><td><var>operator++</var></td><td>`vector deleting destructor'</td></tr>
<tr><th><code>F</code></th><td><var>operator--</var></td><td>`default constructor closure'</td></tr>
<tr><th><code>G</code></th><td><var>operator-</var></td><td>`scalar deleting destructor'</td></tr>
<tr><th><code>H</code></th><td><var>operator+</var></td><td>`vector constructor iterator'</td></tr>
<tr><th><code>I</code></th><td><var>operator&amp;</var></td><td>`vector destructor iterator'</td></tr>
<tr><th><code>J</code></th><td><var>operator-&gt;*</var></td><td>`vector vbase constructor iterator'</td></tr>
<tr><th><code>K</code></th><td><var>operator/</var></td><td>`virtual displacement map'</td></tr>
<tr><th><code>L</code></th><td><var>operator%</var></td><td>`eh vector constructor iterator'</td></tr>
<tr><th><code>M</code></th><td><var>operator&lt;</var></td><td>`eh vector destructor iterator'</td></tr>
<tr><th><code>N</code></th><td><var>operator&lt;=</var></td><td>`eh vector vbase constructor iterator'</td></tr>
<tr><th><code>O</code></th><td><var>operator&gt;</var></td><td>`copy constructor closure'</td></tr>
<tr><th><code>P</code></th><td><var>operator&gt;=</var></td><td>`udt returning' <em>(prefix)</em></td></tr>
<tr><th><code>Q</code></th><td><var>operator,</var></td><td><em>Unknown</em><sup><a id="footnoter3" href="#footnote3">[3]</a></sup></td></tr>
<tr><th><code>R</code></th><td><var>operator()</var></td><td><em>RTTI-related code (see below)</em></td></tr>
<tr><th><code>S</code></th><td><var>operator~</var></td><td>`local vftable'</td></tr>
<tr><th><code>T</code></th><td><var>operator^</var></td><td>`local vftable constructor closure'</td></tr>
<tr><th><code>U</code></th><td><var>operator|</var></td><td><var>operator new[]</var></td></tr>
<tr><th><code>V</code></th><td><var>operator&amp;&amp;</var></td><td><var>operator delete[]</var></td></tr>
<tr><th><code>W</code></th><td><var>operator||</var></td></tr>
<tr><th><code>X</code></th><td><var>operator*=</var></td><td>`placement delete closure'</td></tr>
<tr><th><code>Y</code></th><td><var>operator+=</var></td><td>`placement delete[] closure'</td></tr>
<tr><th><code>Z</code></th><td><var>operator-=</var></td></tr>
</tbody>
</table>
<p>Prefix <code>_P</code> is used as <code>?_PX</code>, though I don't know about it. <small>[TODO: what is udt? user defined type?]</small></p>
<p>Below is RTTI-related code (all starting with <code>_R</code>). Some codes have trailing parameters.</p>
<table>
<thead>
<tr><th>Code</th><th>Meaning</th><th>Trailing Parameters</th></tr>
</thead>
<tbody>
<tr><th><code>_R0</code></th><td><em>type</em> `RTTI Type Descriptor'</td><td><a href="#element-type">Data type</a> <em>type</em>.</td></tr>
<tr><th><code>_R1</code></th><td>`RTTI Base Class Descriptor at (<em>a</em>,<em>b</em>,<em>c</em>,<em>d</em>)'</td><td>Four <a href="#element-number">encoded numbers</a> <em>a</em>, <em>b</em>, <em>c</em> and <em>d</em>.</td></tr>
<tr><th><code>_R2</code></th><td>`RTTI Base Class Array'</td><td>None.</td></tr>
<tr><th><code>_R3</code></th><td>`RTTI Class Hierarchy Descriptor'</td><td>None.</td></tr>
<tr><th><code>_R4</code></th><td>`RTTI Complete Object Locator'</td><td>None.</td></tr>
</tbody>
</table>

<h4 id="element-name-template">Name with Template Arguments</h4>
<p>Name fragment starting with <code>?$</code> has template arguments. This kind of name looks like this:</p>
<ul>
	<li>Prefix <code>?$</code></li>
	<li>Name terminated by <code>@</code></li>
	<li><a href="#element-arglist-template">Template argument list</a></li>
</ul>
<p>For example, we assume the following prototype.</p>
<pre>void __cdecl abc&lt;def&lt;int&gt;,void*&gt;::xyz(void);</pre>
<p>Name of this function can be obtained by the following process:</p>
<pre>
<em>abc&lt;def&lt;int&gt;,void*&gt;::xyz</em>
xyz@ <em>abc&lt;def&lt;int&gt;,void*&gt;</em> @
xyz@ ?$abc@ <em>def&lt;int&gt;</em> <em>void*</em> @ @
xyz@ ?$abc@ V <em>def&lt;int&gt;</em> @ PAX @ @
xyz@ ?$abc@ V ?$def@H@ @ PAX @ @
<strong>xyz@?$abc@V?$def@H@@PAX@@</strong>
</pre>
<p>So mangled name for this function is <code>?<strong>xyz@?$abc@V?$def@H@@PAX@@</strong>YAXXZ</code>.</p>

<h4 id="element-name-nsnum">Numbered Namespace</h4>
<p>In qualification, numbered namespace is represented as preceding <code>?</code> and unsigned <a href="#element-number">number</a>. <var>UnDecorateSymbolName</var> function returns something like <var>`42'</var> for this kind of input.</p>
<p>Exceptionally if numbered namespace starts with <code>?A</code> it becomes anonymous namespace (<var>`anonymous namespace'</var>).</p>
<p>Well, of course I'm not sure what it is. <small>[TODO: what is exact meaning and name? I don't think its name is really "numbered namespace".]</small></p>

<h4 id="element-name-backref">Back Reference</h4>
<p>Decimal digits <code>0</code> to <code>9</code> refers to first shown name fragment to 10th shown name fragment. Referred name fragment can be normal name fragment or name fragment with template arguments. For example, in <code>alpha@?1beta@@</code>(<var>beta::`2'::alpha</var>) <code>0</code> refers to <code>alpha@</code>, and <code>1</code>(not <code>2</code>) refers to <code>beta@</code>.</p>
<p>Generally back reference table is kept during mangling process. It means you can use back reference to function name in function arguments (shown later than function name). However, in <a href="#element-arglist-template">template argument list</a> back reference table is separately created.</p>
<p>For example, assume <code>?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@<strong>2</strong>@@std@@</code>&#8203;(<var>std::basic_string&lt;unsigned short, std::char_traits&lt;unsigned short&gt;, <strong>std</strong>::allocator&lt;unsigned short&gt; &gt;</var>). In <code>std::basic_string&lt;...&gt;</code>, <code>0</code> refers to <code>basic_string@</code>, <code>1</code> refers to <code>?$char_traits@G@</code>, and <code>2</code> refers to <code>std@</code>. This relation doesn't change wherever it is.</p>

<h3 id="element-number">Encoded Number</h3>
<p>In name mangling, representation of number is needed sometimes (e.g. array indices). There are simple rules to represent number:</p>
<ul>
	<li><code>0</code> to <code>9</code> represents number 1 to 10.</li>
	<li><code><em>num</em>@</code> represents hexadecimal number, where <em>num</em> consists of hexadecimal digit <code>A</code>(means 0) to <code>P</code>(means 15). For example <code>BCD@</code> means number 0x123, that is 291.</li>
	<li><code>@</code> represents number 0.</li>
	<li>If allowed, prefix <code>?</code> represents minus sign. Note that both <code>?@</code> and <code>@</code> represents number 0.</li>
</ul>

<h3 id="element-type">Data Type</h3>
<p>The table below shows various data type and modifiers.</p>
<table>
<thead>
<tr><th>Code</th><th>Meaning with no <code>_</code></th><th>Meaning with preceding <code>_</code></th></tr>
</thead>
<tbody>
<tr><th>?</th><td><em>Type modifier, Template parameter</em></td></tr>
<tr><th>$</th><td><em>Type modifier, Template parameter</em><sup><a id="footnoter4" href="#footnote4">[4]</a></sup></td><td>__w64 <em>(prefix)</em></td></tr>
<tr><th>0-9</th><td><em>Back reference</em></td></tr>
<tr><th>A</th><td><em>Type modifier (reference)</em></td></tr>
<tr><th>B</th><td><em>Type modifier (volatile reference)</em></td></tr>
<tr><th>C</th><td>signed char</td></tr>
<tr><th>D</th><td>char</td><td>__int8</td></tr>
<tr><th>E</th><td>unsigned char</td><td>unsigned __int8</td></tr>
<tr><th>F</th><td>short</td><td>__int16</td></tr>
<tr><th>G</th><td>unsigned short</td><td>unsigned __int16</td></tr>
<tr><th>H</th><td>int</td><td>__int32</td></tr>
<tr><th>I</th><td>unsigned int</td><td>unsigned __int32</td></tr>
<tr><th>J</th><td>long</td><td>__int64</td></tr>
<tr><th>K</th><td>unsigned long</td><td>unsigned __int64</td></tr>
<tr><th>L</th><td></td><td>__int128</td></tr>
<tr><th>M</th><td>float</td><td>unsigned __int128</td></tr>
<tr><th>N</th><td>double</td><td>bool</td></tr>
<tr><th>O</th><td>long double</td><td><em>Array</em></td></tr>
<tr><th>P</th><td><em>Type modifier (pointer)</em></td></tr>
<tr><th>Q</th><td><em>Type modifier (const pointer)</em></td></tr>
<tr><th>R</th><td><em>Type modifier (volatile pointer)</em></td></tr>
<tr><th>S</th><td><em>Type modifier (const volatile pointer)</em></td></tr>
<tr><th>T</th><td><em>Complex Type (union)</em></td></tr>
<tr><th>U</th><td><em>Complex Type (struct)</em></td></tr>
<tr><th>V</th><td><em>Complex Type (class)</em></td></tr>
<tr><th>W</th><td><em>Enumerate Type (enum)</em></td><td>wchar_t</td></tr>
<tr><th>X</th><td>void, <em>Complex Type (coclass)</em></td><td><em>Complex Type (coclass)</em></td></tr>
<tr><th>Y</th><td><em>Complex Type (cointerface)</em></td><td><em>Complex Type (cointerface)</em></td></tr>
<tr><th>Z</th><td>... <em>(elipsis)</em></td></tr>
</tbody>
</table>
<p>Actually void for <code>X</code> and elipsis for <code>Z</code> can be used only for terminator of <a href="#element-arglist">argument list</a> or pointer. Otherwise, <code>X</code> is used as cointerface.</p>

<h4 id="element-type-primitive">Primitive &amp; Extended Type</h4>
<p>Primitive types are represented as one character, and extended types are represented as one character preceding <code>_</code>.</p>

<h4 id="element-type-backref">Back Reference</h4>
<p>Decimal digits <code>0</code> to <code>9</code> refers to first shown type to 10th shown type in argument list. (It means return type cannot be referred.) Back reference can refer to any non-primitive type, including extended type. Of course back reference can refer to prefixed type such as <code>PAVblah@@</code>(<var>class blah *</var>), but cannot refer to prefixless type &mdash; say, <code>Vblah@@</code> in <code>PAVblah@@</code>.</p>
<p>As back reference for name, in <a href="#element-arglist-template">template argument list</a> back reference table is separately created. Function argument list has no such scoping rule, though it can be confused sometimes. For example, assume <code>P6AXValpha@@Vbeta@@@Z</code>(<var>void (__cdecl*)(class alpha, class beta)</var>) is first shown non-primitive type. Then <code>0</code> refer to <code>Valpha@@</code>, <code>1</code> refer to <code>Vbeta@@</code>, and finally <code>2</code> refer to function pointer.</p>

<h4 id="element-type-typemod">Type Modifier</h4>
<p>Type modifier is used to make pointer or reference. Type modifier looks like this:</p>
<ul>
	<li>Modifier type</li>
	<li><em>Optional:</em> Managed C++ property (<code>$A</code> for __gc, <code>$B</code> for __pin)</li>
	<li><a href="#element-cvclass">CV-class modifier</a></li>
	<li><em>Optional:</em> Array property (not for function)<ul>
		<li>Prefix <code>Y</code></li>
		<li><a href="#element-number">Encoded unsigned number</a> of dimension</li>
		<li>Array indices as encoded unsigned number, <em>dimension</em> times</li>
	</ul></li>
	<li>Referred type info (see below)</li>
</ul>
<p>There is eight type of type modifier:</p>
<table class="centered-cell">
<thead>
<tr><th></th><th><em>none</em></th><th>const</th><th>volatile</th><th>const volatile</th></tr>
</thead>
<tbody>
<tr><th>Pointer</th><td><code>P</code></td><td><code>Q</code></td><td><code>R</code></td><td><code>S</code></td></tr>
<tr><th>Reference</th><td><code>A</code></td><td></td><td><code>B</code></td><td></td></tr>
<tr><th><em>none</em></th><td><code>?</code><sup><a id="footnoter5" href="#footnote5">[5]</a></sup>, <code>$$C</code></td></tr>
</tbody>
</table>
<p>For normal type, referred type info is <a href="#element-type">data type</a>. For function, it looks like the following. (It depends on CV-class modifier)</p>
<ul>
	<li><em>Conditional:</em> <a href="#element-cvclass">CV-class modifier</a>, if member function</li>
	<li><a href="#element-function">Function property</a></li>
</ul>

<h4 id="element-type-aggregate">Complex Type (union, struct, class, coclass, cointerface)</h4>
<p>Complex type looks like this:</p>
<ul>
	<li>Kind of complex type (<code>T</code>, <code>U</code>, <code>V</code>, ...)<sup><a id="footnoter6" href="#footnote6">[6]</a></sup></li>
	<li><a href="#element-name">Qualification without basic name</a></li>
</ul>

<h4 id="elemene-type-enum">Enumerate Type (enum)</h4>
<p>Enumerate type starts with prefix <code>W</code>. It looks like this:</p>
<ul>
	<li>Prefix <code>W</code></li>
	<li>Real type for enum</li>
	<li><a href="#element-name">Qualification without basic name</a></li>
</ul>
<p>Real type for enum is represented as the following:</p>
<table>
<thead>
<tr><th>Code</th><th>Corresponding Real Type</th></tr>
</thead>
<tbody>
<tr><th><code>0</code></th><td>char</td></tr>
<tr><th><code>1</code></th><td>unsigned char</td></tr>
<tr><th><code>2</code></th><td>short</td></tr>
<tr><th><code>3</code></th><td>unsigned short</td></tr>
<tr><th><code>4</code></th><td>int <em>(generally normal "enum")</em></td></tr>
<tr><th><code>5</code></th><td>unsigned int</td></tr>
<tr><th><code>6</code></th><td>long</td></tr>
<tr><th><code>7</code></th><td>unsigned long</td></tr>
</tbody>
</table>

<h4 id="elemene-type-array">Array</h4>
<p>Array (not pointer to array!) starts with prefix <code>_O</code>. It looks like this:</p>
<ul>
	<li>Prefix <code>_O</code></li>
	<li><a href="#element-cvclass">CV-class modifier</a></li>
	<li><a href="#element-type">Data type</a> within array</li>
</ul>
<p>You can use multi-dimensional array like <code>_OC_OBH</code>, but only the outmost CV-class modifier is affected. (In this case <code>_OC_OBH</code> means <var>int volatile [][]</var>, not <var>int const [][]</var>)</p>

<h4 id="elemene-type-template">Template Parameter</h4>
<p>Template parameter is used to represent type and non-type template argument. It can be used in only <a href="#element-arglist-template">template argument list</a>.</p>
<p>The table below is a list of known template parameters. <em>a</em>, <em>b</em>, <em>c</em> represent <a href="#element-number">encoded signed numbers</a>, and <em>x</em>, <em>y</em>, <em>z</em> represent <a href="#element-number">encoded unsigned numbers</a>.</p>
<table>
<thead>
<tr><th>Code</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><th><code>?<em>x</em></code></th><td>anonymous type template parameter <em>x</em> (<var>`template-parameter-<em>x</em>'</var>)</td></tr>
<tr><th><code>$0<em>a</em></code></th><td>integer value <em>a</em></td></tr>
<tr><th><code>$2<em>a</em><em>b</em></code></th><td>real value <em>a</em> &times; 10<sup><em>b</em>-<em>k</em>+1</sup>, where <em>k</em> is number of decimal digits of <em>a</em><sup><a id="footnoter7" href="#footnote7">[7]</a></sup></td></tr>
<tr><th><code>$D<em>a</em></code></th><td>anonymous type template parameter <em>a</em> (<var>`template-parameter<em>a</em>'</var>)</td></tr>
<tr><th><code>$F<em>a</em><em>b</em></code></th><td>2-tuple {<em>a</em>,<em>b</em>} <em>(unknown)</em></td></tr>
<tr><th><code>$G<em>a</em><em>b</em><em>c</em></code></th><td>3-tuple {<em>a</em>,<em>b</em>,<em>c</em>} <em>(unknown)</em></td></tr>
<tr><th><code>$H<em>x</em></code></th><td><em>(unknown)</em></td></tr>
<tr><th><code>$I<em>x</em><em>y</em></code></th><td><em>(unknown)</em></td></tr>
<tr><th><code>$J<em>x</em><em>y</em><em>z</em></code></th><td><em>(unknown)</em></td></tr>
<tr><th><code>$Q<em>a</em></code></th><td>anonymous non-type template parameter <em>a</em> (<var>`non-type-template-parameter<em>a</em>'</var>)</td></tr>
</tbody>
</table>

<h3 id="element-arglist">Argument List</h3>
<p>Argument list is a sequence of <a href="#element-type">data types</a>. List can be one of the following:</p>
<ul>
	<li><code>X</code> (means <var>void</var>, also terminating list)</li>
	<li><em>arg1</em> <em>arg2</em> ... <em>argN</em> <code>@</code> (means normal list of data types. Note that N can be zero)</li>
	<li><em>arg1</em> <em>arg2</em> ... <em>argN</em> <code>Z</code> (means list with trailing elipsis)</li>
</ul>

<h4 id="element-arglist-template">Template Argument List</h4>
<p>Template argument list is same to argument list, except <a href="#element-type-template">template parameters</a> can be used.</p>

<h3 id="element-cvclass">CV-class Modifier</h3>
<p>The following table shows CV-class modifiers.<sup><a href="footnotex1">*</a></sup></p>
<table class="centered-cell">
<thead>
<tr><th rowspan="2"></th><th colspan="4">Variable</th><th rowspan="2">Function</th></tr>
<tr><td><em>none</em></td><td>const</td><td>volatile</td><td>const volatile</td></tr>
</thead>
<tbody>
<tr><th><em>none</em></th><td><code>A</code></td><td><code>B</code>, <code>J</code></td><td><code>C</code>, <code>G</code>, <code>K</code></td><td><code>D</code>, <code>H</code>, <code>L</code></td><td><code>6</code>, <code>7</code></td></tr>
<tr><th>__based()</th><td><code>M</code></td><td><code>N</code></td><td><code>O</code></td><td><code>P</code></td><td><code>_A</code>, <code>_B</code></td></tr>
<tr><th>Member</th><td><code>Q</code>, <code>U</code>, <code>Y</code></td><td><code>R</code>, <code>V</code>, <code>Z</code></td><td><code>S</code>, <code>W</code>, <code>0</code></td><td><code>T</code>, <code>X</code>, <code>1</code></td><td><code>8</code>, <code>9</code></td></tr>
<tr><th>__based() Member</th><td><code>2</code></td><td><code>3</code></td><td><code>4</code></td><td><code>5</code></td><td><code>_C</code>, <code>_D</code></td></tr>
</tbody>
</table>
<p>CV-class modifier can have zero or more prefix:</p>
<table>
<thead>
<tr><th>Prefix</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><th><code>E</code></th><td><em>type</em> __ptr64</td></tr>
<tr><th><code>F</code></th><td>__unaligned <em>type</em></td></tr>
<tr><th><code>I</code></th><td><em>type</em> __restrict</td></tr>
</tbody>
</table>
<p>Modifiers have trailing parameters as follows:</p>
<ul>
	<li><em>Conditional:</em> <a href="#element-name">Qualification without basic name</a>, if member</li>
	<li><em>Conditional:</em> <a href="#element-cvclass">CV-class modifier</a> of function, if member function</li>
	<li><em>Conditional:</em> <a href="#element-basedprop">__based() property</a>, if used</li>
</ul>
<p>CV-class modifier is usually used in reference/pointer type, but it is also used in other place with some restrictions:</p>
<ul>
	<li>Modifier of function: can only have const, volatile attribute, optionally with prefixes.</li>
	<li>Modifier of data: cannot have function property.</li>
</ul>

<h3 id="element-basedprop">__based() Property</h3>
<p>__based() property represents Microsoft's __based() attribute extension to C++. This property can be one of the following:</p>
<ul>
	<li><code>0</code> (means <var>__based(void)</var>)</li>
	<li><code>2<em>name</em></code> (means <var>__based(<em>name</em>)</var>, where <em>name</em> is <a href="#element-name">qualification without basic name</a>)</li>
	<li><code>5</code> (means no <var>__based()</var>)</li>
</ul>

<h3 id="element-function">Function Property</h3>
<p>Function property represents prototype of function. It looks like this:</p>
<ul>
	<li>Calling convention of function</li>
	<li><a href="#element-type">Data type</a> of returned value, or <code>@</code> for void</li>
	<li><a href="#element-arglist">Argument list</a></li>
	<li>throw() attribute</li>
</ul>
<p>The following table shows calling convention of function:</p>
<table class="centered-cell">
<thead>
<tr><th>Code</th><th>Exported?</th><th>Calling Convention</th></tr>
</thead>
<tbody>
<tr><th><code>A</code></th><td>No</td><td>__cdecl</td></tr>
<tr><th><code>B</code></th><td>Yes</td><td>__cdecl</td></tr>
<tr><th><code>C</code></th><td>No</td><td>__pascal</td></tr>
<tr><th><code>D</code></th><td>Yes</td><td>__pascal</td></tr>
<tr><th><code>E</code></th><td>No</td><td>__thiscall</td></tr>
<tr><th><code>F</code></th><td>Yes</td><td>__thiscall</td></tr>
<tr><th><code>G</code></th><td>No</td><td>__stdcall</td></tr>
<tr><th><code>H</code></th><td>Yes</td><td>__stdcall</td></tr>
<tr><th><code>I</code></th><td>No</td><td>__fastcall</td></tr>
<tr><th><code>J</code></th><td>Yes</td><td>__fastcall</td></tr>
<tr><th><code>K</code></th><td>No</td><td><em>none</em></td></tr>
<tr><th><code>L</code></th><td>Yes</td><td><em>none</em></td></tr>
<tr><th><code>M</code></th><td>No</td><td>__clrcall</td></tr>
</tbody>
</table>
<p>Argument list for throw() attribute is same to <a href="#element-arglist">argument list</a>, but if this list is <code>Z</code>, it means there is no throw() attribute. If you want to use <var>throw()</var> you have to use <code>@</code> instead.</p>

<h2 id="function">Function</h2>
<p>Typical type information in function name looks like this:</p>
<ul>
	<li><em>Optional:</em> Prefix <code>_</code> (means __based() property is used)</li>
	<li>Access level and function type</li>
	<li><em>Conditional:</em> <a href="#element-basedprop">__based() property</a>, if used</li>
	<li><em>Conditional:</em> adjustor property (as <a href="#element-number">encoded unsigned number</a>), if thunk function</li>
	<li><em>Conditional:</em> <a href="#element-cvclass">CV-class modifier</a> of function, if non-static member function</li>
	<li><a href="#element-function">Function property</a></li>
</ul>
<p>The table below shows code for access level and function type:</p>
<table class="centered-cell">
<thead>
<tr><th></th><th><em>none</em></th><th>static</th><th>virtual</th><th>thunk</th></tr>
</thead>
<tbody>
<tr><th>private:</th><td><code>A</code>, <code>B</code></td><td><code>C</code>, <code>D</code></td><td><code>E</code>, <code>F</code></td><td><code>G</code>, <code>H</code></td></tr>
<tr><th>protected:</th><td><code>I</code>, <code>J</code></td><td><code>K</code>, <code>L</code></td><td><code>M</code>, <code>N</code></td><td><code>O</code>, <code>P</code></td></tr>
<tr><th>public:</th><td><code>Q</code>, <code>R</code></td><td><code>S</code>, <code>T</code></td><td><code>U</code>, <code>V</code></td><td><code>W</code>, <code>X</code></td></tr>
<tr><th><em>none</em></th><td><code>Y</code>, <code>Z</code></td></tr>
</tbody>
</table>
<p>This kind of thunk function is always virtual, and used to represent logical <var>this</var> adjustor property, which means an offset to true <var>this</var> value in some multiple inheritance.</p>

<h2 id="data">Data</h2>
<p>Type information in data name looks like this:</p>
<ul>
	<li>Access level and storage class</li>
	<li><a href="#element-type">Data type</a></li>
	<li><a href="#element-cvclass">CV-class modifier</a></li>
</ul>
<p>The table below shows code for access level and storage class:</p>
<table>
<thead>
<tr><th>Code</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><th><code>0</code></th><td>Private static member</td></tr>
<tr><th><code>1</code></th><td>Protected static member</td></tr>
<tr><th><code>2</code></th><td>Public static member</td></tr>
<tr><th><code>3</code></th><td>Normal variable</td></tr>
<tr><th><code>4</code></th><td>Normal variable</td></tr>
</tbody>
</table>
<p>CV-class modifier should not be function.</p>

<h2 id="thunkfunction">Thunk Function</h2>
<p>There is several kind of thunk function. <small>[TODO: a lot of thunk function!]</small></p>

<hr />
<h2>Footnotes</h2>
<p><a id="footnotex1">*</a> Some tables contain two or more entries in one case. In this case, I tried to place more frequently used entry in the front. (But I'm not sure that this placement. Don't ask it for me!)</p>
<p><a id="footnote1" href="#footnoter1">[1]</a> Its meaning depends on return type of function. For instance, if this function returns <code>int</code> type then its name will be <var>operator int</var>.</p>
<p><a id="footnote2" href="#footnoter2">[2]</a> It seems structure after <code>?_C</code> is different from other structure. I think this structure is represented as regular expression <code>\?_C@_[0-9A-P]([0-9A-P][A-P]*)?@.*@</code>, but I'm not sure.</p>
<p><a id="footnote3" href="#footnoter3">[3]</a> It can be EH-related code, but <var>UnDecorateSymbolName</var> function cannot demangle this.</p>
<p><a id="footnote4" href="#footnoter4">[4]</a> There is <code>$$B</code> prefix, but it seems that this prefix can be ignored.</p>
<p><a id="footnote5" href="#footnoter5">[5]</a> <code>?</code> is valid only for type of <a href="#data">data</a>. Also <code>?</code> should be the outmost type modifier. (<code>?CPB</code> is valid but <code>PB?C</code> is not.)</p>
<p><a id="footnote6" href="#footnoter6">[6]</a> <code>?</code> and <code>L</code> can be complex type without any tag such as class, but it can also be a bug of the function.</p>
<p><a id="footnote7" href="#footnoter7">[7]</a> For example, <code>$2HKLH@?2</code> means 3.1415 &times; 10<sup>-3</sup> = 0.0031415, because <code>HKLH@</code> means 31415 and <code>?2</code> means -3.</p>
