<h1><!--(-->난해한 프로그래밍 언어 Malbolge에 대한 프로그램 구성<!--)--></h1>
<div id="metadata">
	<p>이자와 히사시, 사카베 토시키, 사카이 마사히코, 쿠사카리 케이치로, 니시다 나오키<!--((-->이하 나고야 대학 정보 과학 대학원 소속. 전자우편 주소는 편의상 생략함.<!--))--></p>
	<p>엉터리 번역: 강 성훈</p>
</div>

<div class="message">
	<p>이 문서는 〈<a href="http://www.sakabe.i.is.nagoya-u.ac.jp/~nishida/DB/pdf/iizawa05ss2005-22.pdf" lang="ja" hreflang="ja">難読プログラミング言語 Malbolge におけるプログラム構成手法</a>〉의 번역입니다. 물론 lifthrasiir 씨의 일본어 실력은 형편 없음을 유의하시길 바랍니다.</p>
</div>

<p><strong>요약:</strong> Malbolge는 프로그래밍하기 어렵도록 설계된 난해한(esoteric) 프로그래밍 언어이다. 이 논문에서 우리는 소프트웨어 보호에서 난독화(obfuscation)의 적용을 위해 Malbolge로 프로그래밍하는 방법에 대해 제안하고자 한다.</p>
<p><strong>주제어:</strong> 프로그래밍 언어, 소프트웨어 보호, 난독화, Malbolge</p>

<h2>1. 전문</h2>
<p>작성한 프로그램을 불특정 다수의 유저에게 배포할 경우, 시스템의 안정성을 확보하거나 지적 재산권을 보호하기 위하여 프로그램의 내부를 해석하기 힘들도록 만드는 경우가 있다. 이를 위해서 일반적으로는 프로그램을 작성한 뒤 적절한 방법으로 프로그램을 변환하여 해석하기 힘들도록 만드는 방법이 사용된다. 이런 등가 변환을 난독화라 부른다. <a href="#cite1">[1]</a><a href="#cite4">[4]</a></p>
<p>프로그래밍 언어 중에는 난해한 프로그래밍 언어라 불리는 특수한 언어들이 존재한다. 이런 언어들은 설계 목적이 일반적인 언어와는 달라서, 의도적으로 그 언어로의 프로그램 작성이나 이해가 힘들도록 설계되어 있다. 난해한 프로그래밍 언어로 작성된 프로그램은 읽거나 이해하기 힘들기 때문에 난독화는 우수한 반면, 프로그래밍이 힘들다는 문제를 가지고 있다.</p>
<p>본 논문에서 대상으로 하는 언어는 Malbolge라는 언어이다. <a href="#cite2">[2]</a><a href="#cite3">[3]</a> 이것은 <q>인류가 설계할 수 있는 가장 사악한 언어</q>로 불리며 난해한 프로그래밍 언어 중에서도 특히 난해한 것으로 알려져 있다. 아래는 Malbolge의 예제로 작성된 “Hello, world!” 프로그램이다.</p>
<pre>
(=&lt;;:9]~6Z:z2VU/.R2+*)Mn&amp;%I#"!E}|Bzy?wv;zsKqpot3EqpiAm 
lONihKs_d]\['}A0\&gt;&gt;Y&lt;:V97‘R4nON1/EJIHGFEDCB':9]=654XE
</pre>
<p>Malbolge 프로그래밍에 대한 이전 연구<a href="#cite3">[3]</a>는 존재하지만 복잡한 프로그램을 작성할 수 있을 정도까지는 아니었고, Malbolge로 복잡한 프로그램을 작성하는 방법은 일반적으로 알려지지 않았다.</p>
<p>Malbolge로 프로그래밍하는 데 있어 문제는 다음을 들 수 있다.</p>
<ul>
	<li>각 명령이 한정된 기능만을 가지고 있고, 그 기능도 <del>プログラミングに不適であること</del>. <small>[TODO: 프로그래밍에 있어서 말도 안 되는 기능들 뿐이라는 의미]</small></li>
	<li>프로그램을 로드할 때 데이터의 초기치가 현저히 제한되어 있다.</li>
	<li>강제적으로 명령이 동적으로 바꿔 쓰여지기 때문에, 같은 명령열을 반복해 실행하기 힘들다.</li>
</ul>
<p>본 논문에서는 이러한 문제점에 대한 해결책을 보인 후, 이를 통해 Malbolge로 일반적인 프로그램을 작성하는 지침을 보인다.</p>

<h2>2. Malbolge의 명세</h2>

<h3>2.1 환경</h3>
<p>Malbolge에서 한 워드는 10 trit, 즉 3진수 10자리로 표현되어 0부터 59048까지의 값을 가질 수 있다. 메모리 공간은 코드와 데이터가 공유하며, 59049개의 워드로 이루어져 있다. 이는 <code>mem[0]…mem[59048]</code>으로 표현한다. 또한 세 개의 레지스터(<var>A</var>, <var>C</var>, <var>D</var>)가 있는데, <var>A</var>는 누산 레지스터, <var>C</var>는 코드 포인터, <var>D</var>는 데이터 포인터이다.</p>
<p>데이터에 대한 연산자로 trit 연산 <code>op(X, Y)</code>가 있다. 이는 두 입력 값의 각 trit마다 <a href="#table1">표 1</a>로 나타낸 연산을 실시하는 tritwise 이항 연산자이다.</p>
<blockquote><p>예: <code>op([0120120120], [0001112220])</code> → <code>[1001022211]</code></p></blockquote>
<table id="table1">
	<caption>[표 1] <code>op</code> 연산</caption>
	<thead>
		<tr><th colspan="2" rowspan="2"></th><th colspan="3">X<sub>i</sub></th></tr>
		<tr><th>0</th><th>1</th><th>2</th></tr>
	</thead>
	<tbody>
		<tr><th rowspan="3">Y<sub>i</sub></th><th>0</th><td>1</td><td>0</td><td>1</td></tr>
		<tr><th>1</th><td>1</td><td>0</td><td>2</td></tr>
		<tr><th>2</th><td>2</td><td>2</td><td>1</td></tr>
	</tbody>
</table>
<p>프로그램 코드는 모두 출력 가능한 문자(ASCII 33-126)로 구성되며, 로드 시에 모든 문자가 명령으로 해석 가능한 명령 문자인지가 체크된다.</p>
<p>출력 가능한 문자에서 다른 출력 가능한 문자로의 대응표 <var>xlat1</var>과 <var>xlat2</var>가 있다. <var>xlat1</var>은 명령 해석에, <var>xlat2</var>는 명령 문자 치환에 이용된다. 각 변환표는 배열로 다음과 같이 정리되어 있으며, 이들은 전단사 관계이다.</p>
<pre>
const char xlat1[] = 
  "+b(29e*j1VMEKLyC})8&amp;m#~W&gt;qxdRp0wkrUo[D7,XTcA\"lI" 
  ".v%{gJh4G\\-=O@5‘_3i&lt;?Z’;FNQuY]szf$!BS/|t:Pn6^Ha"; 
const char xlat2[] = 
  "5z]&amp;gqtyfr$(we4{WP)H-Zn,[%\\3dL+Q;&gt;U!pJS72FhOA1C" 
  "B6v^=I_0/8|jsb9m&lt;.TVac‘uY*MK’X~xDl}REokN:#?G\"i@"; 
</pre>
<p>여기서 <var>xlat2</var>를 이용해서 출력 가능한 문자 <var>c</var>를 변환하는 것은 <code>xlat2[c-33]</code>으로 표현된다.</p>

<h3>2.2 명령</h3>
<p>Malbolge가 가지고 있는 명령은 다음의 8개 뿐이다. (부록 참조)</p>
<ul>
	<li><code>i</code> &mdash; BRANCH: 분기 명령</li>
	<li><code>j</code> &mdash; LOAD D: 데이터 레지스터 변경 명령</li>
	<li><code>*</code> &mdash; ROTATE: 오른쪽 회전 명령</li>
	<li><code>p</code> &mdash; OPR: 연산 명령</li>
	<li><code>o</code> &mdash; NOOP: 무조작 명령</li>
	<li><code>v</code> &mdash; HALT: 정지 명령</li>
	<li><code>&lt;</code> &mdash; INPUT: 입력 명령</li>
	<li><code>/</code> &mdash; OUTPUT: 출력 명령</li>
</ul>
<p>BRANCH와 LOAD D는 그 시점에서의 <code>mem[D]</code>의 값을 레지스터 <var>C</var> 및 <var>D</var>에 저장하는 명령이다.</p>
<p>ROTATE는 <code>mem[D]</code>의 값을 오른쪽으로 회전<!--((-->최하위 1 trit를 최상위 trit로 올리고, 나머지는 한 trit씩 오른쪽으로 옮긴다.<!--))-->하고, OPR은 <code>op(A, mem[D])</code>를 계산한다. 어느 쪽이나 계산 결과는 <var>A</var>와 <code>mem[D]</code>에 저장된다.</p>
<p>INPUT과 OUTPUT은 표준 입출력으로부터 한 문자를 입출력하는 명령이다.</p>
<p>위에서 맨 앞의 문자(<code>i</code>, <code>j</code>, <code>*</code>, …, <code>/</code>)는 명령 해석 후의 문자를 나타내고 있으며 실행 시점에서는 <code>mem[C]</code>를 해석한 결과가 이러한 문자에 해당할 때 대응하는 명령이 실행된다. <code>mem[C]</code>의 명령 해석은 <code>xlat1[(mem[C]+C-33)%94]</code>로 행해진다. 이 때, 메모리 안의 <var>k</var>번지에 있는 문자 <code>mem[k]</code>가 명령 문자임은 <code>xlat1[(mem[k]+k-33)%94]</code>가 <code>i</code>, <code>j</code>, <code>*</code>, <code>p</code>, <code>o</code>, <code>v</code>, <code>&lt;</code>, <code>/</code> 중의 하나인 경우를 말한다.</p>

<h3>2.3 실행 단계</h3>
<p>한 단계는 다음과 같이 실행된다. (부록 참조)</p>
<ol>
	<li><code>mem[C]</code>를 조사해서 출력 가능한 문자가 아닌 경우에는 <del>暴走する</del>. <small>[TODO: 무한 루프에 빠지는 걸 말하는 듯]</small></li>
	<li><code>mem[C]</code>를 명령으로 해석하여, 그 결과에 대응하는 명령을 실행한다. 어느 명령에도 대응하지 않으면 (명령 문자가 아니면) NOOP와 같다고 간주한다.</li>
	<li><var>xlat2</var>를 이용해 <code>mem[C]</code>를 다른 문자로 치환한다.</li>
	<li><var>C</var>, <var>D</var>를 증가시킨다.</li>
</ol>
<p>이 과정을 정지할 때까지 반복한다.</p>

<h2>3. Malbolge의 문제점</h2>
<p>Malbolge로 프로그래밍을 할 때 해결해야 할 문제점은 주로 다음의 세 가지이다.</p>

<h3>a) 문제점 1</h3>
<p>각 명령이 가지는 기능이 매우 한정적이며, 또 그 기능도 프로그래밍 언어로서 자연스럽다고 말하기 힘들다. 따라서 복수의 명령을 조합해서 고도의 기능을 실현하는 것이 어렵다.</p>
<p>예를 들면, 모든 데이터 조작은 ROTATE와 OPR만으로 이루어져야 하지만, 고도의 연산을 하려고 해도 연산자 <code>op</code>에서는 수학적인 특성을 찾아 내기 어렵다. 또 조건 분기를 실시할 때 대상이 되는 메모리 값에 따라 <code>mem[D]</code>의 값을 다른 주소에 설정해 BRANCH 명령으로 분기시키게 되지만, 이 때 다른 주소로 설정하는 조작도 OPR이나 ROTATE들로 실현되지 않으면 안 된다.</p>

<h3>b) 문제점 2</h3>
<p>복잡한 계산을 실행하기 위해서는 메모리를 적절한 값으로 초기화해야 하지만, Malbolge에서 프로그램 로드시의 데이터의 초기치는 매우 제한되어 있다.</p>
<p>명세에 따르면, 프로그램 코드가 올바르게 로드되려면 프로그램 안의 모든 문자가 명령 문자가 아니면 안 된다고 하는 제약<!--((-->인터프리터<a href="#cite2">[2]</a>에는 버그가 있어서, 출력 가능하지 않은 문자를 그대로 메모리에 로드해 버리는 취약점이 있다.<!--))-->이 있다. 즉, 프로그램 안의 모든 문자가 8종류의 명령 문자로 구성되어 있어야 한다는 제약이며, 이에 따라 프로그램 로드 시의 메모리 한 워드는 8개의 명령 문자 중 하나로밖에 초기화되지 않는다.</p>

<h3>c) 문제점 3</h3>
<p>명세에 따라, 한 번 실행한 명령 문자는 <var>xlat2</var>에 따라 다른 문자로 치환된다. 따라서 한 번 실행한 명령열은 일시적으로 완전히 다른 문자열로 고쳐 쓰여지기 때문에 반복해서 같은 명령열을 실행하기 매우 어렵다.</p>

<h2>4. 문제점 1의 해결</h2>

<h3>4.1 연산자 <code>op</code>의 함수로서의 능력</h3>
<p>OPR과 ROTATE 명령은 C 언어의 비트 연산과 시프트 연산에 대응한다. 따라서 <code>op</code>를 함수 합성하는 것으로 다른 여러 tritwise 함수를 실현할 수 있느냐의 여부는, 덧셈 등의 일반적인 기능을 실현하기 위한 중요한 포인트이다.</p>
<p>예를 들어 1을 증가시키는 함수를 실현하려면 <a href="#table2">표 2</a>와 같은 tritwise 함수가 필요하다. 이 때 <code>Y = [0000000001]</code>으로 이 함수를 적용하면 <var>X</var>의 최하위 trit가 증가된다.</p>
<table id="table2">
	<caption>[표 2] 1 증가를 위한 연산</caption>
	<thead>
		<tr><th colspan="2" rowspan="2"></th><th colspan="3">X<sub>i</sub></th></tr>
		<tr><th>0</th><th>1</th><th>2</th></tr>
	</thead>
	<tbody>
		<tr><th rowspan="3">Y<sub>i</sub></th><th>0</th><td>0</td><td>1</td><td>2</td></tr>
		<tr><th>1</th><td>1</td><td>2</td><td>0</td></tr>
		<tr><th>2</th><td>1</td><td>2</td><td>0</td></tr>
	</tbody>
</table>
<p>먼저 <code>op</code>를 함수 합성하는 것으로 임의의 tritwise 함수를 작성할 수 있는지를 조사했다. 그 결과 임의의 tritwise 함수가 깊이 8까지의 합성으로 실현할 수 있는 것을 확인했다. 다음은 표 2의 함수를 실현하는 합성의 일례이다.</p>
<pre>op(op(op(X, C0), op(C2, op(Y, C0))), op(C2, X))</pre>
<p>여기서 <var>Ci</var>(<var>i</var> = 0, 1, 2)는 각각 모든 trit가 <code><var>i</var></code>인 정수이다.</p>

<h3>4.2 데이터 모듈</h3>
<p>고도의 연산을 실현하려면 데이터나 정수에 반복해서 접근할 수 있어야 한다. 이를 가능하게 하기 위해 대상이 되는 데이터와 연산에 대한 정수, 주소를 하나로 정리한 데이터 모듈이라 하는 데이터 구조를 고안했다. (<a href="#fig1">그림 1</a>)</p>
<div class="gallery centered" id="fig1"><img src="/img/documents/malbolge-99bob-fig1.png"></div>
<p>이 방식을 이용하면 NOOP나 LOAD D 명령을 적당한 횟수 실행해서 데이터 모듈 상의 임의의 위치에 <var>D</var> 레지스터의 포인터를 이동시킬 수 있다. 예를 들어 <var>D</var> 레지스터가 CON1을 가리키고 있는 상태에서 MEM2로 <var>D</var> 레지스터를 위치시키고 싶은 경우, NOOP, NOOP, LOAD D, NOOP를 실행하면 된다. 이런 방법으로 데이터에 대해 반복해서 연산을 실시하는 것이 쉬워졌다.</p>
<p>예를 들어 <code>op(op(C1, MEM2), op(C2, MEM1))</code>을 실현하려면,</p>
<pre>
ROTATE CON2
OPR MEM1
ROTATE CON1
OPR MEM2
OPR MEM1
</pre>
<p>와 같이 실행하면 된다. 여기서 OPR MEM1이란 MEM1로 위치를 옮긴 뒤 OPR을 실행하는 것을 의미한다. 이러한 명령열을 데이터 모듈의 조작열이라 부른다.</p>
<p>다만, 4.1에서 보인 <code>op</code>의 함수 합성은 반드시 데이터 모듈 상에서 실현하기 쉬운 것만 있지는 않기 때문에, 데이터 모듈 상에서 1 증가와 같은 구체적인 기능을 넣을 때가 되면 어느 데이터 모듈에서의 조작열이 어떤 연산 효과를 가질까를 탐색하여 필요한 연산을 실현한다.</p>
<p>예로 1 증가를 위한 데이터 모듈과 그 조작열의 일부를 <a href="#fig2">그림 2</a>에 나타냈다. 이 조작열은 MEM1의 최하위 1 trit를 증가시키는 것으로, 자리수 올림(carry)을 고려하면서 모든 trit에 대해 실행하면 숫자를 1 증가시킬 수 있다.</p>
<div class="gallery centered" id="fig2"><img src="/img/documents/malbolge-99bob-fig2.png" /></div>

<h3>4.3 구체적인 기능 실현</h3>
<p>데이터 모듈을 사용해서 다음과 같은 기능을 실현할 수 있음을 확인했다.</p>
<ul>
	<li>수치 증가 및 감소</li>
	<li>정수 생성</li>
	<li>조건 분기</li>
	<li>주소를 지정해서 데이터를 복사</li>
</ul>
<p>다만 데이터를 복사할 때는 주소를 지정해서 데이터에 접근할 수 있도록 확장한 데이터 모듈을 이용한다.</p>

<h2>5. 문제점 2의 해결</h2>
<p>데이터 모듈을 통해 정수 생성, 즉 명령열을 실행하여 특정한 메모리 혹은 <var>A</var> 레지스터에 임의의 값을 만들어 내는 것이 가능해졌다. 또 4.3에 따라 생성한 값을 지정한 주소에 복사하는 것도 가능해진다.</p>
<p>이로써 (1) 정수를 생성하고 (2) 지정한 주소에 복사한 뒤 (3) 주소를 1 증가하는 조작을 반복하여 원하는 메모리 영역을 자유로운 값으로 초기화하는 것이 가능해졌다.</p>
<p>다만 정수 생성용 데이터 모듈 자신을 구성하는 데는 이 방법을 쓸 수 없기 때문에, 이 데이터 모듈은 다음과 같이 구성한다. 우선 데이터 모듈의 예정 위치를 적당하게 결정하여 적어도 ADR1(<a href="#fig1">그림 1</a> 참조)만은 미리 올바른 값으로 초기화될 수 있도록 한다. 이렇게 하면 최소한 데이터 모듈에의 반복 접근은 가능해진다. 다음에는 다른 메모리의 각 초기치를 잘 이용하여, <code>[0000000001]</code>과 같은 최하위 trit만 다른 데이터를 만들어 내고, 이를 바탕으로 다른 메모리를 한 trit씩 설정한다. 실제로 이 방법으로 제한적인 범위 안에서 정수 생성용 데이터 모듈을 구성할 수 있음을 확인하였다.</p>

<h2>6. 문제점 3의 해결</h2>
<p>앞으로 프로그램이 반복 실행할 수 있는 성질을 루프 내성이라 부르겠다. 루프 내성을 가지는 프로그램을 작성하기 위해 크게 두 개의 아이디어를 이용했다.</p>
<p>첫째는 변환표 <var>xlat2</var>의 주기성이다. <var>xlat2</var>의 변환은 전단사이며, 출력 가능한 문자는 유한하기 때문에 임의의 문자를 반복하여 변환하면 언젠가 반드시 원래 문자로 돌아 온다. (<a href="#fig3">그림 3</a>)</p>
<p>둘째는 BRANCH 명령의 불변성이다. <var>xlat2</var>에 따른 치환은 명령 실행 후의 <code>mem[C]</code>에 대해 행해지므로, BRANCH 명령의 경우 실행 후에도 그 명령 문자가 치환되지 않는다.</p>

<h3>6.1 한정적 루프 내성</h3>
<p>비교적 소규모의 프로그램에서 루프 내성을 실현하는 방법은 <a href="#cite3">[3]</a>에 제시되어 있다.</p>
<p>여기서는 앞에 말한 아이디어 두 개를 모두 이용한다. <var>xlat2</var>의 변환 사이클 중에는, 특정한 메모리에 있으면서 사이클 중에 특정한 명령을 단 한번만 실행하며 다른 부분에서는 어떤 명령도 실행하지 않는 특수한 사이클이 존재한다. 이를 단일 페치 사이클이라 부른다.</p>
<p>예를 들어 <code>mem[8] = '}'</code>에서 <code>}</code>는 ROTATE로 해석되지만, <code>}</code>에서 시작하는 변환 사이클(→ <code>i</code> → <code>*</code> → <code>r</code> → <code>}</code>) 안에서 명령 문자는 <code>}</code> 뿐이며 다른 문자는 실행 시에 NOOP와 동일하게 취급된다.</p>
<p>단일 페치 사이클은 특정한 명령을 실행하는데 루프 내성을 갖고 싶게 할 때 매우 유용하다. 왜냐하면, 그 명령을 실행한 뒤 그 사이클의 주기보다 한 번 적게 반복하여 실행하면, 그 사이에 다른 부작용을 일으키지 않고 원래의 명령 문자로 돌아 오기 때문이다.</p>
<p>명령열의 루프 내성을 실현하려면 대량의 단일 페치 사이클이 필요하지만, 단일 페치 사이클의 빈도는 그다지 크지 않고 메모리 안에 흩어져 존재한다. (특정한 문자가 어느 명령으로 해석되는지는 위치에 의존하기 때문)</p>
<p>이 때문에 여기서는 단일 페치 사이클을 메모리 안에 흩어진 상태로 확보하여, 각각의 직후에 BRANCH 명령을 배치해 징검다리같이 각 사이클을 잇는다. 이와 같이 명령을 배치하면 일단 명령열을 실행한 후 각 사이클의 주기 횟수만큼 실행을 반복하여 다시 원래의 명령열을 얻을 수 있다. 또한 BRANCH 명령 자체는 불변이기 때문에 루프 내성이 실현된다.</p>
<p>예를 들어 명령열 INPUT, OPR, ROTATE의 경우, 각각 주기 2의 단일 페치 사이클이 주소 25, 82, 59에 존재하기 때문에,</p>
<pre>
25: INPUT
26: BRANCH (to 82)
:
:
59: ROTATE
60: BRANCH (to …)
:
:
82: OPR
83: BRANCH (to 59)
</pre>
<p>와 같이 구현한다. 이 경우 주기는 2이므로, 이 명령열을 실행하면 25, 59, 82번지의 명령 문자는 비명령 문자가 되며, 한 번 더 실행하면 명령열이 복원된다.</p>

<h3>6.2 일반적 루프 내성</h3>
<p>6.1의 방법으로는 소규모의 프로그램에 루프 내성을 갖게 할 수 있지만, 대규모 프로그램에는 적용하기 힘들다. 이를 해결하기 위해 기본 모듈 방식을 고안했다. (<a href="#fig3">그림 3</a>)</p>
<div class="gallery centered" id="fig3"><img src="/img/documents/malbolge-99bob-fig3.png" /></div>
<p>이것은 기본 기능을 실현하는 모듈을 미리 6.1 방법으로 루프 내성을 가진 상태로 작성해 두고, 그것들을 서브루틴 호출과 같이 BRANCH 명령으로 호출한다고 하는 방법이다. 필요한 기본 기능을 모두 모듈로서 실현하고 메인 루틴은 이러한 모듈을 호출하기만 한다. 여기서 기본 모듈은 CPU의 명령과 같은 역할을 하며, 메인 루틴은 어셈블리 언어와 같은 것이 된다.</p>
<p>호출하고 싶은 모듈의 주소와 그 인수를 모은 것을 데이터열로 배열해 둔다. BRANCH 명령으로 그 모듈에 제어를 넘기면, 모듈은 인수 데이터를 읽어서 가산이나 대입 등의 연산을 실시하고, 처리가 끝나면 미리 메모리에 보관했던 <var>C</var>, <var>D</var> 레지스터의 값을 바탕으로 서브루틴 호출로부터 복귀한다. 이 조작을 데이터열에 따라 순서대로 실시하여 일반적인 프로그램을 실현할 수 있다.</p>
<p>이 방법에서는 메인 루틴의 코드는 BRANCH 명령만으로 구성되기 때문에, 앞에서 두번째 아이디어에 따라 메인 루틴도 루프 내성을 갖게 할 수 있다.</p>

<h2>7. 일반적인 프로그램의 구성</h2>
<p>여기까지 보인 방법을 이용하여 Malbolge 상에서 일반적인 프로그램을 구성하는 방법을 보인다.</p>

<h3>7.1 기본 모듈의 설계</h3>
<p>기본 모듈 방식으로 이용되는 각종 모듈들은 미리 작성해 둔다. 여기서 각 코드 데이터를 구성하는 워드 값에는 특별한 제한을 가하지 않는다. 한 번 작성한 기본 모듈은 다른 프로그램에서도 재이용할 수 있다.</p>
<p>기본 모듈은 6.1의 방법으로 루프 내성을 갖게 하므로, 그 설계는 다음과 같이 한다.</p>
<ol>
	<li>4.2의 방법으로 모듈의 기능을 실현하는 데이터 모듈과 그를 조작하는 조작열을 설계한다. 단 이 시점에서 이 모듈은 루프 내성을 가지지 않는다.</li>
	<li>설계한 조작열 안의 각 명령에 대해, 그 명령을 실현하는 단일 페치 사이클을 할당하고 그것들이 직후의 BRANCH로 연결되도록 필요한 주소 정보를 데이터 모듈에 삽입한다.</li>
	<li>치환된 명령열을 복원할 때의 실행에 필요한, 더미(dummy) 데이터열을 설계한다.</li>
</ol>

<h3>7.2 메인 루틴의 설계</h3>
<p>각 기본 모듈의 호출을 기술하여 목표하는 기능을 실현하는 메인 루틴을 설계한다. (6.2 참조) 여기에서도 각 코드 데이터를 구성하는 워드 값에 특별한 제한을 가하지 않는다.</p>

<h3>7.3 실행 가능한 프로그램의 작성</h3>
<p>실행 가능한 Malbolge 프로그램 코드를 작성한다. 지금까지 설계한 각종 코드 데이터는 초기화 제한을 무시한 워드열로 되어 있기 때문에 이를 그대로 프로그램 코드로 만들 수 없다. 따라서 5장의 방법을 이용하여 이들 워드열을 메모리 상에 써 넣는다.</p>
<p>다음과 같은 순서로 작동하도록 프로그램을 작성한다.</p>
<ol>
	<li>정수 생성용의 데이터 모듈을 구성한다.</li>
	<li>(1)을 이용하여 영역 초기화에 필요한 데이터 복사 등의 모듈을 메모리 상에 구성한다.</li>
	<li>(1), (2)를 이용하여 각 기본 모듈의 코드 데이터를 메모리 상에 써 넣는다.</li>
	<li>(1), (2)를 이용하여 메인 루틴의 코드 데이터를 메모리 상에 써 넣는다.</li>
	<li>남은 메모리 영역은 자유롭게 이용 가능한 영역으로, 0으로 채운다.</li>
	<li>메인 루틴에 제어를 넘긴다.</li>
</ol>

<h3>7.4 자동화에 대한 고찰</h3>
<p>지금껏 기술한 프로그램의 구성 방법은 사람의 손으로 하기에는 매우 번거롭다. 따라서 이러한 방법을 자동적으로 실시하는 컴파일러를 만들 수 있는가가 중요하다. 여기서 컴파일러란, 어떤 다른 언어를 입력으로 하여 이를 구현하는 Malbolge 프로그램을 출력하는 것을 의미한다.</p>
<p>컴파일러를 만들려면 위의 각 순서를 고려할 필요가 있지만, 반드시 모든 처리를 컴파일러로 할 필요는 없다. 왜냐하면 위의 순서 가운데 ‘메인 루틴의 설계’와 ‘실행 가능한 프로그램의 작성’의 (4)를 제외한 처리는 입력 프로그램과 무관하게 고정이므로, 미리 사람의 손으로 프로그램을 작성하여 컴파일 시에 그것을 링크하는 것만으로 충분하기 때문이다.</p>
<p>따라서 컴파일러에서 실현해야 하는 처리는 아래의 두 가지 뿐이며, 이들은 자동화 가능하다고 본다.</p>
<ul>
	<li>입력 프로그램을 해석하여 그를 실현하는 메인 루틴을 구성한다.</li>
	<li>메인 루틴의 코드 데이터를 메모리 상에 쓰기 위한, 정수 생성 모듈의 조작열을 생성한다.</li>
</ul>

<h2>8. 정리</h2>
<p>본 논문에서는 난해한 프로그래밍 언어인 Malbolge를 선택하여, 이 Malbolge로 프로그래밍을 하는데 있어서 각 문제점에 대하여 해결법을 보이고 일반적인 프로그램을 구성하는 방법을 보였다.</p>
<p>앞으로의 과제로는, 컴파일러를 사용하여 얻어진 프로그램의 난독화의 강도, 즉 역변환의 난이도에 대해 평가를 실시할 필요가 있다고 생각한다. 다만 기본 모듈 방식을 사용한 구현은 당연히 난독화의 강도를 상당히 저하시킨다고 볼 수 있으므로, 적절한 대응책이 필요하다고 생각한다.</p>
<p>사례: 본 연구는 나고야 대학 21세기 COE 프로그램(사회 정보 기반을 위한 음성 영상의 지적 통합)의 보조를 일부 받아 행해졌다.</p>

<h2>참고 문헌</h2>
<ol>
	<li id="cite1"><del>門田暁人, 高田義広, 鳥居宏次, “プログラムの難読化法の実験的評価, ” 情処学ソフトウェア工学研報, vol.96, no.32, pp.33–40, Mar.1996.</del> <small>[TODO: 이름 읽기 귀찮아서 그냥 내버려 둠]</small></li>
	<li id="cite2">Malbolge: Programming from Hell (archived)<br />URL: <a>http://web.archive.org/web/20010613070437/www.mines.edu/students/b/bolmstea/malbolge/</a></li>
	<li id="cite3">Programming in Malbolge<br />URL: <a>http://www.lscheffer.com/malbolge.html</a></li>
	<li id="cite4">소프트웨어 보호<br />URL: <a>http://se.aist-nara.ac.jp/themes/protection</a></li>
</ol>

<h2>부록</h2>

<h3>1. Malbolge 인터프리터 실행부</h3>
<p>Malbolge의 인터프리터에서 실행 부분은 다음과 같이 C 언어로 비교적 간결히 기술된다.</p>
<pre><![CDATA[
void exec( unsigned short *mem ) 
{ 
  unsigned short a = 0, c = 0, d = 0; 
  int x; 
  for (;;) 
  { 
    if ( mem[c] < 33 || mem[c] > 126 ) continue; 
    switch ( xlat1[( mem[c] - 33 + c ) % 94] ) 
    { 
      case ’j’: d = mem[d]; break; 
      case ’i’: c = mem[d]; break; 
      case ’*’: 
        a = mem[d] = mem[d] / 3 + mem[d] % 3 * 19683; 
        break; 
      case ’p’: a = mem[d] = op( a, mem[d] ); break; 
      case ’<’: putc( a, stdout ); break; 
      case ’/’: 
        x = getc( stdin ); 
        if ( x == EOF ) a = 59048; else a = x; 
        break; 
      case ’v’: return; 
    } 
    mem[c] = xlat2[mem[c] - 33]; 
    if ( c == 59048 ) c = 0; else c++; 
    if ( d == 59048 ) d = 0; else d++; 
  } 
} 
]]></pre>

