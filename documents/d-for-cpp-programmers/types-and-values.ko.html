<h1><small>C/C++ 프로그래머를 위한 D:</small><br /><!--(-->자료형과 값<!--)--></h1>
<p>(TODO 아 쓰기 귀찮다.)</p>

<h2>기본 자료형</h2>
<p>D의 기본 자료형은 사실 C/C++랑 별로 다를 게 없다. 그냥 둘을 비교해 보자.</p>
<table summary="D의 기본 자료형과 C/C++의 기본 자료형 비교." class="centered">
	<thead>
		<tr><th>D 자료형</th><th>C/C++ 자료형</th><th>설명</th></tr>
	</thead>
	<tbody>
		<tr><th><var>void</var></th><td><var>void</var></td><td></td></tr>
		<tr><th><var>bool</var></th><td><var>bool</var>, <var>_Bool</var></td><td>논리값</td></tr>
		<tr><th><var>byte</var></th><td><var>signed char</var></td><td>8비트 부호 있는 정수</td></tr>
		<tr><th><var>ubyte</var></th><td><var>unsigned char</var></td><td>8비트 부호 없는 정수</td></tr>
		<tr><th><var>short</var></th><td><var>signed short</var></td><td>16비트 부호 있는 정수</td></tr>
		<tr><th><var>ushort</var></th><td><var>unsigned short</var></td><td>16비트 부호 없는 정수</td></tr>
		<tr><th><var>int</var></th><td><var>signed int</var></td><td>32비트 부호 있는 정수</td></tr>
		<tr><th><var>uint</var></th><td><var>unsigned int</var></td><td>32비트 부호 없는 정수</td></tr>
		<tr><th><var>long</var></th><td><var>signed long long</var></td><td>64비트 부호 있는 정수</td></tr>
		<tr><th><var>ulong</var></th><td><var>unsigned long long</var></td><td>64비트 부호 없는 정수</td></tr>
		<tr><th><var>float</var></th><td><var>float</var></td><td>32비트 부동 소숫점 실수</td></tr>
		<tr><th><var>double</var></th><td><var>double</var></td><td>64비트 부동 소숫점 실수</td></tr>
		<tr><th><var>real</var></th><td><var>long double</var></td><td>가장 정밀한 부동 소숫점 실수<!--((-->우리가 보통 쓰는 IA-32(x86)에서는 80비트<!--))--></td></tr>
		<tr><th><var>ifloat</var></th><td><var>float _Imaginary</var></td><td>32비트 부동 소숫점 허수</td></tr>
		<tr><th><var>idouble</var></th><td><var>double _Imaginary</var></td><td>64비트 부동 소숫점 허수</td></tr>
		<tr><th><var>ireal</var></th><td><var>long double _Imaginary</var></td><td>가장 정밀한 부동 소숫점 허수</td></tr>
		<tr><th><var>cfloat</var></th><td><var>float _Complex</var>, <var>std::complex&lt;float&gt;</var></td><td>32×2비트 부동 소숫점 복소수</td></tr>
		<tr><th><var>cdouble</var></th><td><var>double _Complex</var>, <var>std::complex&lt;double&gt;</var></td><td>64×2비트 부동 소숫점 복소수</td></tr>
		<tr><th><var>creal</var></th><td><var>long double _Complex</var>,<br /><var>std::complex&lt;long double&gt;</var></td><td>가장 정밀한 부동 소숫점 복소수</td></tr>
		<tr><th><var>char</var></th><td><var>char</var></td><td>UTF-8 문자열</td></tr>
		<tr><th><var>wchar</var></th><td><var>wchar_t</var></td><td>UTF-16 문자열</td></tr>
		<tr><th><var>dchar</var></th><td><var>wchar_t</var></td><td>UTF-32 문자열</td></tr>
	</tbody>
</table>
<p>뭔가 쓸데 없이 복잡하다는 생각이 들지만 요약하면,</p>
<ul>
	<li>자바, C#과 같이 자료형 이름이 항상 한 예약어이고 (u 붙으면 부호 없음, 안 붙으면 부호 있음) 크기가 무조건 정해져 있다.</li>
	<li><var>char</var>과 <var>byte</var>/<var>ubyte</var>는 항상 구분된다. 심지어 <var>char</var>는 어떤 인코딩을 써야 할지 정해져 있다.</li>
	<li>허수 자료형과 복소수 자료형이 예약어로 따로 있다. 왜 이런 자료형이 들어 갔는지 궁금하다면, 요즘 언어들의 트렌드라고 이해하면 대강 맞을 것이다.<!--((-->사실 이 트렌드가 생긴 가장 큰 이유는 언어 차원에서 복소수 자료형을 강제하지 않으면 자기 맘대로 다 만들어 버리기 때문이고, 서로 호환성이 떨어지기 때문이다. C에서도 이 문제를 인식한듯 <var>_Complex</var> 예약어를 도입했지만 이미 때는 늦었다.<!--))--></li>
	<li>문자 형이 세 가지나 있다.</li>
</ul>
<p>숫자 뒤에 <code>u</code>(부호 없는 정수), <code>L</code>(<var>long</var>이나 <var>real</var>), <code>i</code>(허수 자료형)을 붙이면 해당 타입으로 변환할 수 있지만, 복소수 자료형을 쓰지 않는 한 자동으로 자료형을 인식해서 변환 등을 해 주기 때문에 그다지 염려할 필요는 없다. 복소수 자료형은 따로 리터럴은 없지만 실수와 허수 리터럴을 더해서 얻을 수 있다.</p>

<h2>문자와 문자열</h2>
<p>좀 전에 정수와 실수는 다 얘기했다. 그럼 문자는 어쩌냐? 이것도 뭐 다를 건 없다. 하지만 인코딩 운운하는 소리를 했으니 그걸 함께 설명할 겸 따로 빼 냈다.</p>
<p>만약 자기가 나름 프로그래밍을 한다고 생각하는데 <a href="http://unicode.org/">유니코드</a>를 모른다면 두 손 들고 반성하길 바란다. 아마 윈도 프로그래머라면 W 붙은 윈도 <abbr>API</abbr> 함수가 유니코드 인자를 받는다는 정도는 알 것이다. 유니코드는 기본적으로 하나의 문자에 적절한 숫자를 배당하고, 각 문자의 성질과 얘네들을 가지고 어떤 연산을 할 수 있는지 정해 놓은 것이다. 예를 들어서 ‘가’ 같은 문자에는 44032라는 번호가 붙어 있고, 얘는 한글 음절 영역에 속해 있으며 대소문자 구분이 없고 ‘ㄱㅏ’ 식으로 변환될 수 있다… 같은 것이 모두 유니코드에 들어 있는 것이다. 당연히 유니코드 문자들로 이루어진 문자열을 바이트로 표현하는 규약도 있는데 이런 것들을 유니코드 인코딩이라고 부른다.</p>
<p>UTF-8, UTF-16, UTF-32의 차이는 몇 바이트 단위로 저장되느냐의 문제고, 단위가 크면 클수록 간단하게 처리할 수 있지만 대신 차지하는 용량이 커진다. D는 상황에 맞는 인코딩을 알아서 선택해서 쓰도록 문자 자료형을 <var>char</var>, <var>wchar</var>, <var>dchar</var> 세 개로 분리해 놓은 것이다. (사실 C/C++에도 이런 이유로 문자 자료형이 두 개 있으니, 세 개 있다고 크게 불평할 것은 없다. 어차피 상호 변환하는 함수도 있다.)</p>
<p>서론이 길었다. 하여튼 C/C++와 마찬가지로 문자 값은 <code>'a'</code>, 문자열 값은 <code>"asdf"</code> 식으로 쓴다. 물론 이게 무슨 자료형인지는 문맥에 맞춰서 적절히 변환되니 따로 지정해 줄 필요는 없지만, 꼭 필요하다면 <code>"asdf"w</code> 식으로 자료형을 지정해 줄 수 있다.</p>
<p>각 인코딩으로 표현된 문자열은 std.utf 모듈의 <var>toUTF8</var> 등의 함수로 변환할 수 있다. 예를 들어서,</p>
<pre><![CDATA[
import std.utf;
// …
wchar[] s = toUTF16("ㅁㄴㅇㄹ\U0010ffff"d); // UTF-32를 UTF-16으로 변환한다.
char[] s2 = toUTF8(s); // UTF-16을 UTF-8로 변환한다.
]]></pre>
<p>물론 C/C++와 똑같은 형태의 탈출 문자열(<code>\</code>로 시작하는 것들)을 쓸 수 있고, 유니코드 문자 코드를 위한 탈출 문자열(<code>\uXXXX</code>나 <code>\UXXXXXXXX</code>)도 존재한다.<!--((-->C/C++와의 차이점은 <code>\x</code> 뒤에는 아무리 많아도 16진수 두 자리까지만 올 수 있다는 것이다. C/C++는 <var>char</var>과 <var>wchar_t</var>에서 같은 탈출 문자열을 써야 하기 때문에 이 뒤에 두 자리가 넘는 16진수가 들어 갈 수도 있다.<!--))--></p>
<p>…그래서 이 세 개의 인코딩 중 뭘 써야 하냐? 라고 물을 수 있겠다. 뭐 <em>취향을 존중해야</em> 겠지만 내 생각에는,</p>
<ul>
	<li>보통 때는 <var>char</var>을 쓴다. 사실 main 함수로 넘어 오는 인자도 <var>char[]</var>이다!</li>
	<li>만약 유니코드 문자 하나 하나를 처리해야 한다면 (예를 들어서, 한글 몇 글자인지 센다거나) <var>dchar</var>로 변환한다.</li>
	<li>윈도 API 같은 데에 문자열을 넘겨 줘야 한다면 <var>wchar</var>로 변환한다. std.utf 모듈에는 정확히 이 용도로 사용하기 위한 <var>toUTF16z</var> 함수가 따로 있다.</li>
</ul>

<h2>배열</h2>

