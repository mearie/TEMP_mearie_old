<h1><small>C/C++ 프로그래머를 위한 D:</small><br /><!--(-->시작하기<!--)--></h1>
<p>언제나 그렇지만 프로그래밍 언어를 배울 때는 직접 부닥쳐 보면서 배우는 게 제일이다. 백문이 불여일견이라는 말도 있지 않는가? 그러니 한 번 직접 첫 D 프로그램을 짜 보기로 하자.</p>

<h2>개발 환경 설정</h2>
<pre>
TODO:
dmd 받기 gdc 받기
가능하다면 C::B 사용법도?
</pre>

<h2>첫 D 프로그램</h2>
<p>이제 한 번 D 프로그램을 하나 짜 보자. 첫 프로그램은 우리가 잘 알고 있는 Hello, world…로 하려다가 너무 재미가 없으니 <a href="http://ko.wikipedia.org/wiki/%EB%B3%84_%EC%B0%8D%EA%B8%B0">별 찍기</a>도 같이 하도록 하자.</p>
<pre><![CDATA[
import std.stdio;
import std.conv;

int main(char[][] args)
{
	writefln("Hello, world! I am %s.", args[0]);

	// 덤으로 별찍기:
	if (args.length > 1) {
		int size = toInt(args[1]);
		for (int i = size; i >= 1; --i) {
			for (int j = 1; j <= i; ++j) {
				writef('*');
			}
			writefln("");
		}
	}

	return 0;
}
]]></pre>
<p>D 소스 코드의 확장자는 (당연하게도) <code>.d</code>이다. 적절한 이름으로 저장해 두기로 하자.</p>
<pre>TODO: 컴파일하고 실행하기...</pre>

<h2>첫 D 프로그램 해부하기</h2>
<p>이제 위에서 짠 코드를 한 줄씩 분석하기로 하자. 물론 C/C++에 익숙하다면 위의 코드가 C/C++ 코드와 크게 다를 걸 없다는 걸 알겠지만, 그래도 이왕 하는 겸 관련된 내용도 같이 설명하겠다.</p>

<h3>모듈 들여 오기</h3>
<p>우리가 짠 D 코드의 첫 두 줄은 다음과 같다.</p>
<pre><![CDATA[
import std.stdio;
import std.conv;
]]></pre>
<p>아마 C/C++ 프로그래머라면 다음 코드를 바로 떠올렸음직 하다.</p>
<pre><![CDATA[
#include <stdio.h> /* C++라면 <cstdio> */
#include <stdlib.h> /* C++라면 <cstdlib> */
]]></pre>
<p>그리고 하는 일도 뭐 별반 다르지 않다. <code>import std.stdio;</code>는 writef와 writefln을 쓰기 위해 필요한 거고, <code>import std.conv;</code>는 toInt를 쓰기 위해 필요한 거다.</p>
<p>D에서는 이런 하나의 소스 코드 유닛을 ‘모듈’이라 부른다. 잠깐, 그럼 헤더는 어디 있는 거냐고? 보통 D에서는 헤더와 소스 코드를 크게 구분하지 않는다. (물론 헤더 비스무리한 뭔가<!--((-->D 인터페이스 모듈이라 하여 확장자가 <code>.di</code>인 파일은 선언만을 포함할 수 있다.<!--))-->가 있긴 하지만, 이건 굳이 알지 않아도 사는데 문제 없다.) 그냥 파일 하나 만들고, 그 파일이 해당하는 모듈 이름으로 들여 오면 끝이다. 순환 참조는 컴파일러가 알아서 처리해 주므로 걱정할 필요가 없다. 이런 들여 오기는 파이썬이나 자바를 써 봤다면 더 쉽게 이해할 수 있을 것이다.</p>
<p><code>std.</code>로 시작하는 모듈들은 D 표준 라이브러리, 즉 포보스(phobos)에 들어 있는 모듈들이다. 앞으로 지겹게 보게 될 이름이니 미리 익숙해지도록 하자.</p>

<h3>main 함수</h3>
<p>C/C++ 같은 언어와 마찬가지로 D에서 프로그램의 시작도 main 함수이다. 위에서 이 함수는 다음과 같이 정의되어 있다.</p>
<pre><![CDATA[
int main(char[][] args)
{
	…
}
]]></pre>
<p>함수 선언은 C/C++와 크게 다르지 않다. 하지만 main 함수의 인자가 argc, argv 두 개가 아니라 단 하나, args 뿐이라는 건 좀 생소할 것이다. 이 인자에 대해 설명하려면 두 가지를 설명해야 한다.</p>
<ul>
	<li>첫번째, D에서 어떤 자료형 <code>T</code>의 배열은 <code>T[]</code>로 쓴다. C/C++에서 배열로 인자를 넘겨 주면 사실은 포인터만 넘어 가지만, D의 배열과 포인터는 그 역할이 완전히 구분되어 있다. 특히 배열에는 길이가 있기 때문에 이 길이를 넘어 가는 곳을 참조하려고 하면 무작정 죽거나 하는 게 아니라 잘 정해진 동작을 한다. C++ 프로그래머라면 이 배열이 <code>std::vector&lt;T&gt;</code> 형이랑 같고 인자 참조할 때 <code>at</code> 메소드를 쓴다고 생각하면 이해가 편할 것이다.</li>
	<li>두번째, C/C++와는 다르게 <code>[]</code>가 이름 뒤가 아니라 자료형 뒤에 붙는다. 짐작했겠지만 포인터도 <code>T*</code>로 쓴다. 혹시 이게 자바스러워서 싫다? 이런 사람들을 위해 D는 이름 뒤에 붙이는 문법도 지원하긴 한다. 하지만 웬만하면 새 문법을 쓰는 게 나중에 다른 코드를 볼 때를 생각하면 더 나을 것이다.</li>
</ul>
<p>그리고 앞에서 두 가지라고 썼지만 아무래도 혼란스러울 것 같아서 따로 뺀 게 하나 있으니,</p>
<ul>
	<li>세번째, D의 문자열 형은 단순히 문자 배열일 뿐이다. 그래서 자료형은 <code>char[]</code>이 된다. 물론 널 문자로 끝날 필요도 없다.</li>
</ul>
<p>따라서 main 함수는 <em>문자열(문자 배열)의 배열</em>을 인자로 받고, 인자 갯수는 배열의 크기로부터 알 수 있다. 깔끔하지 않은가?</p>

<h3>문자열 출력</h3>
<p>main 함수의 첫 줄은 함수 호출이다. 옛 선인들<!--((-->사실 Hello, world 프로그램을 처음 쓴 사람은 유닉스와 C로 널리 알려진 브라이언 커니핸이었다!<!--))-->의 전통을 따라 이 함수는 “Hello, world!” 문장을 출력한다.</p>
<pre><![CDATA[
	writefln("Hello, world! I am %s.", args[0]);
]]></pre>
<p>writefln 함수는 앞에서 들여 온 std.stdio 모듈에 있고, 이름도 뻔하지만 포매팅(f)된 문자열과 개행 문자(nl)를 출력(write)하라는 의미이다. 여기서 ln만 빼면 영락 없는 C/C++의 printf 함수다. 두번째 인자인 <code>args[0]</code>은, 당연하게도, args의 첫 원소인 프로그램 이름을 돌려 준다.</p>
<p>한 번 심심하니 코드를 다음과 같이 고쳐 보시라.</p>
<pre><![CDATA[
	writefln("Hello, world! I am %s.", 42);
]]></pre>
<p>삑! 삑! 머릿속에서 경고음이 들려 온다면 여러분은 훌륭한 C/C++ 프로그래머입니다. 하지만 D 프로그래머로는 멀었군요. 위 코드는 D에서 아무 문제 없이 잘 실행됩니다.</p>
<p>사건의 전말은 이렇다. D도 C/C++ 함수와 마찬가지로 가변 인자 함수(인자의 갯수가 변할 수 있는 함수)를 지원하지만, 한 번 삐끗하면 바로 터져 버리는 C/C++와는 달리 D는 들어 온 인자들의 형 정보도 함께 함수에게 넘겨 준다. 그래서 writefln은 첫 인자가 <code>int</code> 형이지만 문자열로 출력되어야 한다는 걸 알고 알아서 변환해 준 것이다.</p>
<p>만약 인자를 아예 빼 버리면 어떨까?</p>
<pre><![CDATA[
	writefln("Hello, world! I am %s.");
]]></pre>
<p>이번에도 역시, writefln은 인자가 포매팅 문자열 뿐인 걸 알고 그 문자열을 그대로 출력한다. (즉 <code>%s</code>는 해석되지 않는다) 인자의 형 뿐만 아니라 그 갯수도 알고 있기 때문에 가능한 것이다.</p>

<h3>제어문</h3>
<p>Hello, world를 출력한 뒤에 나타나는 코드는 별-_-찍기이다. 이 코드는 함수가 너무 허전해서 한 번 넣어 본 것이기 때문에 사실 크게 설명할 부분은 없다.</p>
<pre><![CDATA[
	// 덤으로 별찍기:
	if (args.length > 1) {
		int size = toInt(args[1]);
		for (int i = size; i >= 1; --i) {
			for (int j = 1; j <= i; ++j) {
				writef('*');
			}
			writefln("");
		}
	}
]]></pre>
<p>먼저 첫 줄의 주석문은 C++ 형태의 주석문이다. (C만 해 보신 분을 위해서, <code>//</code>로 시작하는 주석은 줄 끝까지 무시된다.) 물론 C 형태의 주석문 <code>/* … */</code>도 됨은 물론이고. 여기에 덤으로 D는 중첩 가능한 주석문 <code>/+ … +/</code>을 제공한다.</p>
<pre><![CDATA[
/+
if (cond) {
	// 아래 코드는 아마 무시될 것임
	/+
	writefln("cond is true!");
	+/
}
+/
]]></pre>
<p>C/C++ 프로그래머라면 이 용도로 <code>#if 0</code>과 <code>#endif</code>를 대신 썼을 것이다. 사실 D에서 특정 코드를 무시하는 방법은 이거 말고도 몇 가지가 있는데, 일단은 이런 것도 있다는 걸 알아 두고 넘어 가자. 추후에 언급할 일이 있을 것이다.</p>
<p>그 다음 if 문은 args가 하나 이상의 원소를 가지고 있으면 실행된다. <code>length</code>는 이름이 말해 주듯 배열의 길이를 반환한다. (C++ 프로그래머라면 <code>size()</code> 메소드를 떠올리시라.) 이런 식으로 쓸 수 있는 것은 배열 길이 뿐만이 아닌데, 이를테면 C/C++에서 <code>sizeof(blah)</code>라고 썼을 코드는 <code>blah.sizeof</code>라고 쓴다. 이런 것들을 통틀어서 속성(attribute)이라고 하고 변수, 식, 심지어는 자료형 따위에 모두 적용할 수 있다.</p>
<p>세번째 줄은 std.conv 모듈에 있는 toInt라는 함수를 써서 첫번째 인자(<code>args[0]</code>는 프로그램 이름이니까)를 숫자로 바꾼다. 변수 선언은 C/C++나 D나 다를 게 없고, 단지 C 프로그래머는 C++처럼 변수를 아무 데나 선언할 수 있다는 걸 기억해 두면 좋겠다. 네번째 줄과 다섯번째 줄에서 볼 수 있듯이 if, for 같은 제어문에서 선언이 가능하다는 점도 잊지 말자.</p>
<p>여섯번째 줄에서 writef에 문자형인 <code>'*'</code>가 포맷 문자열로 들어 가는 건 앞에서 설명한 걸 생각하면 충분히 이해할 수 있을 것이다. 인자가 하나만 들어 오면 어떤 값이든 문자열로 변환해서 출력하는 것이다.</p>

<h2>그 다음에는…</h2>
<p>이렇게 해서 첫 D 프로그램을 해부해 봤다. D 코드는 C/C++ 프로그래머가 이해하기 어렵지 않다는 말을 실감할 수 있을 것이다. 게다가 C/C++를 쓰면서 자주 실수할 법한 것들을 알아서 처리해 준다는 점도 장점이 되겠다.</p>
<p>다음 장에서는 자료형과 값에 대해서 좀 더 자세히 알아 보기로 하겠다.</p>

