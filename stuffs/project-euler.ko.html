<h1>프로젝트 오일러 노트</h1>
<p>이 페이지는 <a href="http://projecteuler.net/">프로젝트 오일러</a>에 게재된 문제들에 대한 짤막한 노트입니다. 답은 담고 있지 않지만 심각한(?) 스포일러를 담고 있을 수 있으므로 내가 이산수학에는 젬병이라 어떻게 해야 할 지 모른다거나 하지 않으면 그냥 안 보는 게 좋습니다.</p>
<p>제 프로젝트 오일러 아이디는 <a href="http://projecteuler.net/index.php?section=profile&amp;profile=lifthrasiir">lifthrasiir</a>입니다. (로그인 필요) 파이썬을 주로 사용하고 있습니다. 아래에서 <del>지운</del> 것은 아직 못 푼 것입니다.</p>

<h2>1~50</h2>
<p>1번은 자명. (수식으로 풀 수도 있다)</p>
<p>2번은 자명.</p>
<p>3번은 개인적으로 만들어 쓰는 정수론 라이브러리를 사용해서 풀었다. (함수 이름이 factorize이다.)</p>
<p>4번은 단순히 가능한 모든 경우를 체크해서 해결했다.</p>
<p>5번은 lcm(1,…,20)을 구하는 것으로 해결된다. evenly divisible이라는 말은 나눈 몫이 짝수라는 얘기고, 이미 해당 숫자에 4가 들어 있으므로 별로 달라질 건 없다.</p>
<p>6번은 그냥 루프.</p>
<p>7번은 3번과 마찬가지로 정수론 라이브러리 동원. GMPY를 쓴다면 next_prime 함수를 쓸 수도 있다. 정 못 하겠으면 OEIS A000040 참조.</p>
<p>8번은 역시 그냥 루프.</p>
<p>9번은 범위가 크지 않으므로 쉽게 풀린다. 위키백과에서 어떻게 triple을 생성해 내는지 확인해 볼 것. (그냥 가능한 a, b, c 목록을 뽑아도 되긴 하지만)</p>
<p>10번은 루프 돌렸다. 에라토스테네스의 체를 써도 쉽게 될 것이다. 내가 만든 isprime 함수는 SPRP를 체크하는 식인데 이게 느린 건지 빠른지는 잘 모르겠다.</p>
<p>11번은 가능한 경우를 모두 체크하면 된다. 단지 한 줄로 쓰기가 좀 귀찮긴 한데 나는 모든 숫자를 줄 사이에 k개의 더미 값을 넣어서 1차원 리스트 만들고 step을 1, -1, 20+k, -(20+k), 19+k, 21+k로 해서 검사하게 했다.</p>
<pre>구찮으니 건너 뛰고</pre>

<h2>51~100</h2>
<p>52번은 생각할 필요 없이 머릿속에서 떠오르는 숫자를 집어 넣으니 바로 정답.</p>
<p>53번은 이항 계수를 점진적으로(r이 0부터 n까지 증가하므로) 계산할 수 있으면 쉽게 풀린다.</p>
<p>55번은 문제에서 53단계 넘어 가는 게 없다고 했기 때문에 테스트를 해 보고 53단계 넘으면 자르면 된다.</p>
<p>56번은 루프 돌렸다.</p>
<p>57번은 continued fraction을 점진적으로 구하면 된다. 일종의 Lucas sequence처럼 구하면 되었던 듯.</p>
<p>58번은 각 단계에서 추가되는 네 개의 숫자를 수식으로 쉽게 구할 수 있으므로 자명하다.</p>
<p>59번은 키 길이가 주어져 있기 때문에 키에서 같은 문자에 대응되는 암호문끼리 따로 나눠서 빈도 분석을 하면 나온다. 전형적인 Vigenere cipher 푸는 방법과 같다.</p>
<p>61번은 계산을 편리하게 하기 위해 첫 두 자리씩 묶어서 사전으로 저장한 뒤 11중-_-; 루프를 돌렸다. <small>(2008-11-01)</small></p>
<p>62번은 세제곱해서 여덟 자리가 되는 것, 아홉 자리가 되는 것, …등을 계산한 뒤 자릿수들을 정렬한 것으로 묶었다.</p>
<pre>…</pre>
<p>71번은 이렇게 생각할 수 있다. 각 분모 m에 대해, 1부터 m-1까지의 분자를 테스트하는데 m이랑 서로 소가 아니면 더 작은 분모에서 이미 그 값이 포함되었을 것이다. 따라서 중복되는 것을 빼고 나면 &phi;(2)부터 &phi;(1000000)까지 모두 더한 것과 같다.</p>
<p>72번은 71번과 비슷하게 서로 소인 것만 체크하면 된다.</p>
<p>74번은 memorization을 이용해서 이미 계산한 것은 더 이상 계산하지 않도록 하면 쉽게 구할 수 있다. 참고로 문제에 제시된 루프 말고 자기 자신으로 바로 돌아 가는 (145같은) 숫자가 있기 때문에 주의해야 한다.</p>
<pre>…</pre>
<p>79번은 손으로 가능한 것들을 정리해가면서 풀었다.</p>
<pre>…</pre>
<p>96번은 원래 파이썬으로 풀었다가 너무 느려서 C로 다시 짰다. 스도쿠는 백트래킹을 사용해도 얼마 지나지 않아 풀린다. (만약 더 큰 보드가 주어진다면 <abbr title="Integer Linear Programming">ILP</abbr>, 좀 더 정확하게는 exact cover가 되고 DLX 같은 걸로 풀어야 한다.)</p>
<p>97번은 파이썬을 쓴다면 자명. 코드도 공개하겠다: <code>print (28433 * pow(2, 7830457, 10**10) + 1) % 10**10</code></p>
<pre>…</pre>

<h2>101~150</h2>
<p>102번은 외적을 사용한 시계방향/반시계방향 판별 로직을 써서 풀 수 있다. (흔히 isCCW 같은 이름이 붙어 있는 함수인데 외적을 쓰니 직접 만들어 봐도 되겠다.) 꼭지점 자체는 순서가 정해져 있지 않으므로 방향이 일정한 값을 가지는 게 아니라 같은지를 체크해야 함을 유의.</p>
<p>104번은 처음에는 OEIS A112371의 목록만 가져다가 첫 9자리가 조건에 맞는지 체크하게 해서 풀었다. 게시판 글들 보고 나서야 모든 자릿수를 다 계산할 필요가 없다는 게 떠올랐다. <small>(2008-10-31)</small></p>
<pre>…</pre>
<p>122번은 addition chain과 관련된 문제이다. 이 문제 자체는 NP-_-로 알려져 있기 때문에 쉽게 구하긴 힘들고, 그냥 OEIS A003313을 사용했다.</p>
<pre>…</pre>
<p><del>137번에서 제시된 함수는 피보나치 수열의 generating function으로부터 닫힌 형태(closed form)로 변환할 수 있다. <small>(2008-11-01)</small></del></p>
<pre>…</pre>

<h2>151~200</h2>
<p>155번은 DP를 써서 풀었다. 캐퍼시터 한 개부터 18개까지 반복하면서 그것들을 둘로 나누고 직렬과 병렬로 연결할 경우에 대해서 계산해서 경우의 수를 구했다. GMPY의 mpq가 편했다.</p>
<p>159번은 사실은 정말 쉬운 DP이다. mdrs 함수는 곱셈적 함수이기 때문에 그냥 순서대로 구하면 된다. (그냥 곱셈적이면 두 수가 서로 소일 때나 쓸 수 있겠지만 이 경우에는 서로 소가 아닌 경우에도 곱셈적이다.)</p>
<pre>…</pre>
<p>173번은 타일 갯수의 수식을 만드는 것으로 풀 수 있다. 구멍 한 변이 n이고, 테두리 두께가 m일 때 사용되는 타일 수는 (n+2m)<sup>2</sup> - n<sup>2</sup> = 4(n+m)m이고, 단순히 각 숫자의 약수를 구해서 테스트해 봐도 된다. <small>(2008-10-30)</small></p>
<p>174번은 173번과 사실상 같은 문제이다.</p>
<pre>…</pre>
<p>197번은 직접 f의 첫 몇 항을 출력해 보면 답이 눈에 보일 것이다. (…) 하도 황당해서 fixed point도 찾을 생각 안 하고 바로 정답 찍었다.</p>
<pre>…</pre>

<h2>201~</h2>
<p>202번은 거울에 비친 삼각형 공간을 사실은 무한히 뻗어 있다고 가정하고 시각화하면 쉽게 이해할 수 있다. 이렇게 만들어진 격자 상의 각 점에 좌표를 붙인 뒤 좌표가 가져야 할 조건을 구하면 경우의 수를 줄일 수 있다.</p>
<pre>…</pre>
<p>208번은 각 이동을 다섯 종류의 벡터로 생각해서 구할 수 있다. 이 벡터에 v<sub>1</sub>부터 v<sub>5</sub>까지의 이름을 붙이면 v<sub>1</sub> + … + v<sub>5</sub> = 0이 되고, 다른 linear combination이 0이 되는 경우가 없으므로 (이게 사실 확신은 안 갔는데 게시판에 증명이 있다.) 합이 0이 되는 경로를 memorization으로 찾을 수 있다. <small>(2008-10-30)</small></p>
<p>209번은 2<sup>64</sup>가지 경우의 수가 있기 때문에 백트래킹으로 풀기 어렵다. a라는 6-tuple이 있을 때 &tau;(a)가 1이면 &tau;(f(a))가 1이 될 수 없고, &tau;(f(a))가 1이면 &tau;(f(f(a)))가 1이 될 수 없고… 하는 의존 관계를 그래프로 표현하면 몇 개의 strongly connected component가 나오는데 이들에 인접한 정점에 둘 다 1을 채우지 않는 경우의 수를 구해서 모두 곱하면 된다. 참고로 &tau;(0,0,0,0,0,0)은 조건때문에 항상 0이어야 한다. <small>(2008-10-31)</small></p>
<pre>…</pre>

